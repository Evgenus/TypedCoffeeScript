// Generated by CoffeeScript 2.0.0-beta8-dev
var checkAcceptableObject, console, CS, initializeGlobalTypes, pj, render, Scope, TypeSymbol, VarSymbol;
console = {
  log: function () {
  }
};
pj = function () {
  try {
    return require('prettyjson');
  } catch (e$) {
    return;
  }
}.call(this);
render = function (obj) {
  if (null != pj)
    return pj.render(obj);
};
CS = require('./nodes');
checkAcceptableObject = function (left, right) {
  console.log('check', left, right);
  if (typeof left === 'string' && typeof right === 'string') {
    if (left === right || left === 'Any' || right === 'Any') {
      return 'ok';
    } else {
      throw new Error('object deep equal mismatch ' + left + ', ' + right);
    }
  } else if (null != (null != left ? left.array : void 0)) {
    return console.log('left', left, 'right', right);
  } else if (typeof left === 'object' && typeof right === 'object') {
    return function (accum$) {
      var key, lval;
      for (key in left) {
        lval = left[key];
        if (right[key] === void 0) {
          if (key === 'returns' || key === 'type')
            return;
          throw new Error("'" + key + "' is not defined on right");
        }
        accum$.push(checkAcceptableObject(lval, right[key]));
      }
      return accum$;
    }.call(this, []);
  } else if (left === void 0 || right === void 0) {
    return 'ignore now';
  } else {
    throw new Error('object deep equal mismatch ' + left + ', ' + right);
  }
};
initializeGlobalTypes = function (node) {
  node.addTypeObject('String', new TypeSymbol({
    type: 'String',
    'instanceof': function (expr) {
      return typeof expr.data === 'string';
    }
  }));
  node.addTypeObject('Number', new TypeSymbol({
    type: 'Number',
    'instanceof': function (expr) {
      return typeof expr.data === 'number';
    }
  }));
  node.addTypeObject('Boolean', new TypeSymbol({
    type: 'Boolean',
    'instanceof': function (expr) {
      return typeof expr.data === 'boolean';
    }
  }));
  node.addTypeObject('Object', new TypeSymbol({
    type: 'Object',
    'instanceof': function (expr) {
      return typeof expr.data === 'object';
    }
  }));
  node.addTypeObject('Array', new TypeSymbol({
    type: 'Array',
    'instanceof': function (expr) {
      return typeof expr.data === 'object';
    }
  }));
  return node.addTypeObject('Any', new TypeSymbol({
    type: 'Any',
    'instanceof': function (expr) {
      return true;
    }
  }));
};
VarSymbol = function () {
  function VarSymbol(param$) {
    var cache$;
    {
      cache$ = param$;
      this.type = cache$.type;
      this.implicit = cache$.implicit;
    }
  }
  return VarSymbol;
}();
TypeSymbol = function () {
  function TypeSymbol(param$) {
    var cache$;
    {
      cache$ = param$;
      this.type = cache$.type;
      this['instanceof'] = cache$['instanceof'];
    }
    if (null != this['instanceof'])
      this['instanceof'];
    else
      this['instanceof'] = function (t) {
        return t instanceof this.constructor;
      };
  }
  return TypeSymbol;
}();
Scope = function () {
  function Scope(param$) {
    if (null == param$)
      param$ = null;
    this.parent = param$;
    if (null != this.parent)
      this.parent.nodes.push(this);
    this.name = '';
    this.nodes = [];
    this._vars = {};
    this._types = {};
    this._this = null;
    this._returnables = [];
  }
  Scope.prototype.addReturnable = function (symbol, type) {
    return this._returnables.push(type);
  };
  Scope.prototype.getReturnables = function () {
    return this._returnables;
  };
  Scope.prototype.addType = function (symbol, type) {
    return this._types[symbol] = new TypeSymbol({ type: type });
  };
  Scope.prototype.addTypeObject = function (symbol, type_object) {
    return this._types[symbol] = type_object;
  };
  Scope.prototype.getType = function (symbol) {
    return null != (null != this._types[symbol] ? this._types[symbol].type : void 0) ? null != this._types[symbol] ? this._types[symbol].type : void 0 : void 0;
  };
  Scope.prototype.getTypeInScope = function (symbol) {
    return this.getType(symbol) || (null != this.parent ? this.parent.getTypeInScope(symbol) : void 0) || void 0;
  };
  Scope.prototype.addVar = function (symbol, type, implicit) {
    if (null == implicit)
      implicit = true;
    return this._vars[symbol] = new VarSymbol({
      type: type,
      implicit: implicit
    });
  };
  Scope.prototype.getVar = function (symbol) {
    return null != (null != this._vars[symbol] ? this._vars[symbol].type : void 0) ? null != this._vars[symbol] ? this._vars[symbol].type : void 0 : void 0;
  };
  Scope.prototype.getVarInScope = function (symbol) {
    return this.getVar(symbol) || (null != this.parent ? this.parent.getVarInScope(symbol) : void 0) || void 0;
  };
  Scope.prototype.isImplicitVar = function (symbol) {
    return !!(null != this._vars[symbol] ? this._vars[symbol].implicit : void 0);
  };
  Scope.prototype.isImplicitVarInScope = function (symbol) {
    return this.isImplicitVar(symbol) || (null != this.parent ? this.parent.isImplicitVarInScope(symbol) : void 0) || void 0;
  };
  Scope.prototype.extendTypeLiteral = function (node) {
    var key, ret, type, val;
    switch (typeof node) {
    case 'object':
      if (node instanceof Array) {
        return function (accum$) {
          var i;
          for (var i$ = 0, length$ = node.length; i$ < length$; ++i$) {
            i = node[i$];
            accum$.push(this.extendTypeLiteral(i));
          }
          return accum$;
        }.call(this, []);
      } else {
        ret = {};
        for (key in node) {
          val = node[key];
          ret[key] = this.extendTypeLiteral(val);
        }
        return ret;
      }
    case 'string':
      type = this.getTypeInScope(node);
      switch (typeof type) {
      case 'object':
        return this.extendTypeLiteral(type);
      case 'string':
        return type;
      }
    }
  };
  Scope.prototype.checkFunctionLiteral = function (left, right) {
    var i, l_arg, r_arg;
    left = this.extendTypeLiteral(left);
    right = this.extendTypeLiteral(right);
    for (var i$ = 0, length$ = left.args.length; i$ < length$; ++i$) {
      l_arg = left.args[i$];
      i = i$;
      r_arg = right.args[i];
      checkAcceptableObject(l_arg, r_arg);
    }
    if (right.returns !== 'Any')
      return checkAcceptableObject(left.returns, right.returns);
  };
  Scope.prototype.checkArrayLiteral = function (left, right) {
    var i, l_arg, r_arg;
    left = this.extendTypeLiteral(left);
    right = this.extendTypeLiteral(right);
    for (var i$ = 0, length$ = left.args.length; i$ < length$; ++i$) {
      l_arg = left.args[i$];
      i = i$;
      r_arg = right.args[i];
      checkAcceptableObject(l_arg, r_arg);
    }
    return checkAcceptableObject(left.returns, right.returns);
  };
  Scope.dump = function (node, prefix) {
    var key, val;
    if (null == prefix)
      prefix = '';
    console.log(prefix + ('[' + node.name + ']'));
    for (key in node._vars) {
      val = node._vars[key];
      console.log(prefix, ' +', key, '::', val);
    }
    return function (accum$) {
      var next;
      for (var i$ = 0, length$ = node.nodes.length; i$ < length$; ++i$) {
        next = node.nodes[i$];
        accum$.push(Scope.dump(next, prefix + '  '));
      }
      return accum$;
    }.call(this, []);
  };
  return Scope;
}();
module.exports = {
  checkAcceptableObject: checkAcceptableObject,
  initializeGlobalTypes: initializeGlobalTypes,
  VarSymbol: VarSymbol,
  TypeSymbol: TypeSymbol,
  Scope: Scope
};
