// Generated by CoffeeScript 2.0.0-beta8-dev
var checkAcceptableObject, checkNodes, console, CS, initializeGlobalTypes, pj, render, Scope, TypeSymbol, VarSymbol, walk, walk_block, walk_program, walk_return, walk_struct;
console = {
  log: function () {
  }
};
pj = function () {
  try {
    return require('prettyjson');
  } catch (e$) {
    return;
  }
}.call(this);
render = function (obj) {
  if (null != pj)
    return pj.render(obj);
};
CS = require('./nodes');
cache$ = require('./types');
checkAcceptableObject = cache$.checkAcceptableObject;
initializeGlobalTypes = cache$.initializeGlobalTypes;
VarSymbol = cache$.VarSymbol;
TypeSymbol = cache$.TypeSymbol;
Scope = cache$.Scope;
checkNodes = function (cs_ast) {
  var i, root;
  if (!(null != (null != cs_ast.body ? cs_ast.body.statements : void 0)))
    return;
  console.log('AST ==================');
  console.log('================== AST');
  root = new Scope;
  root.name = 'root';
  for (var cache$1 = [
        'global',
        'exports',
        'module'
      ], i$ = 0, length$ = cache$1.length; i$ < length$; ++i$) {
    i = cache$1[i$];
    root.addVar(i, 'Any', true);
  }
  initializeGlobalTypes(root);
  walk(cs_ast, root);
  console.log('scope =====================');
  Scope.dump(root);
  return console.log('finish ================== checkNodes');
};
walk_struct = function (node, scope) {
  return scope.addType(node.name, node.expr);
};
walk_program = function (node, scope) {
  walk(node.body.statements, scope);
  return node.annotation = { type: 'Program' };
};
walk_block = function (node, scope) {
  var last_annotation;
  walk(node.statements, scope);
  last_annotation = null != node.statements[node.statements.length - 1] ? node.statements[node.statements.length - 1].annotation : void 0;
  return node.annotation = last_annotation;
};
walk_return = function (node, scope) {
  walk(node.expression, scope);
  if (null != (null != node.expression && null != node.expression.annotation ? node.expression.annotation.type : void 0)) {
    scope.addReturnable(node.expression.annotation.type);
    return node.annotation = node.expression.annotation;
  }
};
walk = function (node, scope) {
  var alternate_annotation, args, assigning, cache$2, el, expected, expression, functionScope, i, infered, key, last_expr, left, left_type, n, nextScope, nop, obj, possibilities, registered, right, right_type, symbol, type;
  console.log('---', null != node ? node.className : void 0, '---', null != node ? node.raw : void 0);
  switch (false) {
  case !!(null != node):
    return;
  case !(null != node.length):
    return function (accum$) {
      var s;
      for (var i$ = 0, length$ = node.length; i$ < length$; ++i$) {
        s = node[i$];
        accum$.push(walk(s, scope));
      }
      return accum$;
    }.call(this, []);
  case !(node.type === 'struct'):
    return walk_struct(node, scope);
  case !node['instanceof'](CS.Program):
    return walk_program(node, scope);
  case !node['instanceof'](CS.Block):
    return walk_block(node, scope);
  case !node['instanceof'](CS.Return):
    return walk_return(node, scope);
  case !(node['instanceof'](CS.PlusOp) || node['instanceof'](CS.MultiplyOp) || node['instanceof'](CS.DivideOp) || node['instanceof'](CS.SubtractOp)):
    console.log('binops', node.className);
    walk(node.left, scope);
    walk(node.right, scope);
    left_type = null != node.left && null != node.left.annotation ? node.left.annotation.type : void 0;
    right_type = null != node.right && null != node.right.annotation ? node.right.annotation.type : void 0;
    if (left_type && right_type) {
      if (left_type === 'String' || right_type === 'String') {
        return node.annotation = { type: 'String' };
      } else if (left_type === right_type) {
        return node.annotation = {
          type: left_type,
          implicit: false
        };
      }
    } else {
      node.annotation = {
        type: 'Any',
        implicit: true
      };
      return console.log(render(node));
    }
  case !node['instanceof'](CS.SubtractOp):
    node.annotation = { type: 'Number' };
    walk(node.left, scope);
    return walk(node.right, scope);
  case !node['instanceof'](CS.Conditional):
    walk(node.condition, scope);
    walk(node.consequent, scope);
    if (null != node.alternate)
      walk(node.alternate, scope);
    alternate_annotation = null != (null != node.alternate ? node.alternate.annotation : void 0) ? null != node.alternate ? node.alternate.annotation : void 0 : {
      type: 'Undefined',
      implicit: true
    };
    possibilities = [];
    for (var cache$1 = [
          null != node.consequent ? node.consequent.annotation : void 0,
          alternate_annotation
        ], i$ = 0, length$ = cache$1.length; i$ < length$; ++i$) {
      n = cache$1[i$];
      if (!('undefined' !== typeof n && null != n))
        continue;
      if (null != n.possibilities) {
        for (var i$1 = 0, length$1 = n.possibilities.length; i$1 < length$1; ++i$1) {
          i = n.possibilities[i$1];
          possibilities.push(i);
        }
      } else {
        possibilities.push(n);
      }
    }
    return node.annotation = {
      possibilities: possibilities,
      implicit: true
    };
  case !(node['instanceof'](CS.ForIn) || node['instanceof'](CS.ForOf)):
    walk(node.target, scope);
    if (null != node.valAssignee)
      scope.addVar(node.valAssignee.data, null != (null != node.valAssignee && null != node.valAssignee.annotation ? node.valAssignee.annotation.type : void 0) ? null != node.valAssignee && null != node.valAssignee.annotation ? node.valAssignee.annotation.type : void 0 : 'Any');
    if (null != node.keyAssignee)
      scope.addVar(node.keyAssignee.data, null != (null != node.keyAssignee && null != node.keyAssignee.annotation ? node.keyAssignee.annotation.type : void 0) ? null != node.keyAssignee && null != node.keyAssignee.annotation ? node.keyAssignee.annotation.type : void 0 : 'Any');
    if (null != (null != node.target.annotation && null != node.target.annotation.type ? node.target.annotation.type.array : void 0)) {
      for (var i$2 = 0, length$2 = (null != node.target.annotation && null != node.target.annotation.type ? node.target.annotation.type.array : void 0).length; i$2 < length$2; ++i$2) {
        el = (null != node.target.annotation && null != node.target.annotation.type ? node.target.annotation.type.array : void 0)[i$2];
        if (null != node.valAssignee)
          scope.checkAcceptableObject(node.valAssignee.annotation.type, el);
      }
    } else if ((null != node.target && null != node.target.annotation ? node.target.annotation.type : void 0) instanceof Object) {
      if (node.target.annotation.type instanceof Object) {
        for (nop in node.target.annotation.type) {
          type = node.target.annotation.type[nop];
          scope.checkAcceptableObject(node.valAssignee.annotation.type, type);
        }
      }
    }
    walk(node.body, scope);
    node.annotation = null != node.body ? node.body.annotation : void 0;
    delete scope._vars[null != node.valAssignee ? node.valAssignee.data : void 0];
    return delete scope._vars[null != node.keyAssignee ? node.keyAssignee.data : void 0];
  case !node['instanceof'](CS.String):
    if (null != node.annotation)
      return node.annotation;
    else
      return node.annotation = {
        type: 'String',
        implicit: true,
        primitive: true
      };
  case !node['instanceof'](CS.Bool):
    if (null != node.annotation)
      return node.annotation;
    else
      return node.annotation = {
        type: 'Boolean',
        implicit: true,
        primitive: true
      };
  case !node['instanceof'](CS.Numbers):
    if (null != node.annotation)
      return node.annotation;
    else
      return node.annotation = {
        type: 'Number',
        implicit: true,
        primitive: true
      };
  case !node['instanceof'](CS.Identifier):
    if (scope.getVarInScope(node.data)) {
      return node.annotation = { type: scope.getVarInScope(node.data) };
    } else {
      if (null != node.annotation)
        return node.annotation;
      else
        return node.annotation = {
          type: 'Any',
          implicit: true
        };
    }
  case !node['instanceof'](CS.MemberAccessOps):
    if (node['instanceof'](CS.MemberAccessOp)) {
      walk(node.expression, scope);
      type = scope.extendTypeLiteral(null != node.expression.annotation ? node.expression.annotation.type : void 0);
      if (null != type) {
        return node.annotation = {
          type: type[node.memberName],
          implicit: false
        };
      } else {
        return node.annotation = {
          type: 'Any',
          implicit: true
        };
      }
    }
  case !node['instanceof'](CS.ArrayInitialiser):
    walk(node.members, scope);
    if (null != node.annotation)
      return node.annotation;
    else
      return node.annotation = {
        type: {
          array: null != node.members ? node.members.map(function (m) {
            return null != m.annotation ? m.annotation.type : void 0;
          }) : void 0
        },
        implicit: true
      };
  case !node['instanceof'](CS.Range):
    return node.annotation = { type: { array: 'Number' } };
  case !node['instanceof'](CS.ObjectInitialiser):
    obj = {};
    nextScope = new Scope(scope);
    nextScope.name = 'object';
    for (var i$3 = 0, length$3 = node.members.length; i$3 < length$3; ++i$3) {
      {
        cache$2 = node.members[i$3];
        expression = cache$2.expression;
        key = cache$2.key;
      }
      if (!('undefined' !== typeof key && null != key))
        continue;
      walk(expression, nextScope);
      obj[key.data] = null != expression.annotation ? expression.annotation.type : void 0;
    }
    if (null != node.annotation)
      return node.annotation;
    else
      return node.annotation = {
        type: obj,
        implicit: true
      };
  case !node['instanceof'](CS.Class):
    return walk(node.body.statements, new Scope(scope));
  case !node['instanceof'](CS.Function):
    args = null != node.parameters ? node.parameters.map(function (param) {
      return null != (null != param.annotation ? param.annotation.type : void 0) ? null != param.annotation ? param.annotation.type : void 0 : 'Any';
    }) : void 0;
    node.annotation.type.args = args;
    functionScope = new Scope(scope);
    functionScope.name = 'function';
    if (null != node.parameters)
      node.parameters.map(function (param) {
        try {
          if ('function' === typeof functionScope.addVar)
            return functionScope.addVar(param.data, null != (null != param.annotation ? param.annotation.type : void 0) ? null != param.annotation ? param.annotation.type : void 0 : 'Any');
        } catch (e$) {
          return 'ignore but brake on somewhere. why?';
        }
      });
    walk(node.body, functionScope);
    if ((null != node.annotation && null != node.annotation.type ? node.annotation.type.returns : void 0) !== 'Any') {
      last_expr = (null != node.body && null != node.body.statements ? node.body.statements.length : void 0) ? null != node.body.statements ? node.body.statements[(null != node.body && null != node.body.statements ? node.body.statements.length : void 0) - 1] : void 0 : node.body;
      return scope.checkAcceptableObject(node.annotation.type.returns, null != last_expr.annotation ? last_expr.annotation.type : void 0);
    } else {
      last_expr = (null != node.body && null != node.body.statements ? node.body.statements.length : void 0) ? null != node.body.statements ? node.body.statements[(null != node.body && null != node.body.statements ? node.body.statements.length : void 0) - 1] : void 0 : node.body;
      if (null != node.annotation)
        return node.annotation.type.returns = null != last_expr && null != last_expr.annotation ? last_expr.annotation.type : void 0;
    }
  case !node['instanceof'](CS.FunctionApplication):
    walk(node['arguments'], scope);
    expected = scope.getVarInScope(node['function'].data);
    if (null != expected && expected !== 'Any') {
      args = null != node['arguments'] ? node['arguments'].map(function (arg) {
        return null != arg.annotation ? arg.annotation.type : void 0;
      }) : void 0;
      scope.checkFunctionLiteral(expected, {
        args: args,
        returns: 'Any'
      });
      if (null != node.annotation)
        return node.annotation;
      else
        return node.annotation = {
          type: expected.returns,
          implicit: true
        };
    }
  case !node['instanceof'](CS.AssignOp):
    left = node.assignee;
    right = node.expression;
    walk(right, scope);
    walk(left, scope);
    if (!(null != left))
      return;
    if (left['instanceof'](CS.Identifier)) {
      symbol = left.data;
      registered = scope.getVarInScope(symbol);
      infered = null != right.annotation ? right.annotation.type : void 0;
      assigning = null != left.annotation ? scope.extendTypeLiteral(left.annotation.type) : void 0;
      if (null != assigning && null != registered && assigning !== 'Any') {
        throw new Error('double bind: ' + symbol);
      } else if (null != registered) {
        if (symbol === 'toString')
          return;
        if (!(registered === infered || registered === 'Any'))
          throw new Error("'" + symbol + "' is expected to " + registered + ' indeed ' + infered + ', by assignee');
      } else if (null != assigning) {
        console.log('---- xxx ---');
        console.log(render(right));
        if (assigning === 'Any') {
          return scope.addVar(symbol, 'Any', true);
        } else if (right['instanceof'](CS.Conditional)) {
          return function (accum$) {
            var p;
            for (var i$4 = 0, length$4 = right.annotation.possibilities.length; i$4 < length$4; ++i$4) {
              p = right.annotation.possibilities[i$4];
              accum$.push(scope.checkAcceptableObject(assigning, p.type));
            }
            return accum$;
          }.call(this, []);
        } else if (right['instanceof'](CS.ForIn)) {
          return scope.checkAcceptableObject(assigning.array, scope.extendTypeLiteral(right.annotation.type));
        } else if (null != (null != right.annotation && null != right.annotation.type ? right.annotation.type.array : void 0)) {
          if (typeof right.annotation.type.array === 'string') {
            scope.checkAcceptableObject(assigning.array, right.annotation.type.array);
          } else if (null != right.annotation.type.array.length) {
            for (var i$4 = 0, length$4 = right.annotation.type.array.length; i$4 < length$4; ++i$4) {
              el = right.annotation.type.array[i$4];
              scope.checkAcceptableObject(assigning.array, el);
            }
          }
          return scope.addVar(symbol, 'Any', true);
        } else if (null != left.annotation.type.args && null != right.annotation.type.args) {
          if (right['instanceof'](CS.Function)) {
            scope.checkFunctionLiteral(left.annotation.type, right.annotation.type);
          } else {
            throw new Error('Right is not function');
          }
          return scope.addVar(symbol, left.annotation.type);
        } else if (typeof assigning === 'object') {
          if (null != right.annotation && null != left.annotation) {
            scope.checkAcceptableObject(assigning, right.annotation.type);
            return scope.addVar(symbol, left.annotation.type, false);
          }
        } else if (assigning === infered) {
          return scope.addVar(symbol, left.annotation.type);
        } else {
          if (symbol === 'toString')
            return;
          throw new Error("'" + symbol + "' is expected to " + left.annotation.type + ' indeed ' + infered);
        }
      }
    } else if (left['instanceof'](CS.MemberAccessOp)) {
      if (left.expression.raw === '@')
        return;
      if (null != (null != left.annotation ? left.annotation.type : void 0) && null != (null != right.annotation ? right.annotation.type : void 0))
        if (left.annotation.type !== 'Any') {
          return scope.checkAcceptableObject(left.annotation.type, right.annotation.type);
        }
    } else {
      return scope.addVar(symbol, 'Any');
    }
  }
};
module.exports = { checkNodes: checkNodes };
