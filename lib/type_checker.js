// Generated by CoffeeScript 1.6.3
(function() {
  var CS, ClassScope, FunctionScope, Scope, checkNodes, g, initializeGlobalTypes, pj, render, reporter, walk, walk_arrayInializer, walk_assignOp, walk_binOp, walk_block, walk_bool, walk_class, walk_classProtoAssignOp, walk_conditional, walk_for, walk_function, walk_functionApplication, walk_identifier, walk_memberAccess, walk_newOp, walk_numbers, walk_objectInitializer, walk_primitives, walk_program, walk_range, walk_return, walk_string, walk_struct, walk_switch, walk_this, walk_vardef, _ref;

  pj = (function() {
    try {
      return require('prettyjson');
    } catch (_error) {}
  })();

  render = function(obj) {
    return pj != null ? pj.render(obj) : void 0;
  };

  reporter = require('./reporter');

  CS = require('./nodes');

  _ref = require('./types'), initializeGlobalTypes = _ref.initializeGlobalTypes, Scope = _ref.Scope, ClassScope = _ref.ClassScope, FunctionScope = _ref.FunctionScope;

  g = typeof window !== "undefined" && window !== null ? window : global;

  checkNodes = function(cs_ast) {
    var i, root, _i, _len, _ref1, _ref2;
    if (((_ref1 = cs_ast.body) != null ? _ref1.statements : void 0) == null) {
      return;
    }
    if (g._root_) {
      root = g._root_;
    } else {
      g._root_ = root = new Scope;
      root.name = 'root';
      _ref2 = ['global', 'exports', 'module'];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        i = _ref2[_i];
        root.addVar(i, 'Any', true);
      }
      initializeGlobalTypes(root);
    }
    walk(cs_ast, root);
    return root;
  };

  walk_struct = function(node, scope) {
    if (node.name instanceof Object) {
      return scope.addType(node.name._base_, node.expr, node.name._templates_);
    } else {
      return scope.addType(node.name, node.expr);
    }
  };

  walk_vardef = function(node, scope) {
    if (scope instanceof ClassScope) {
      return scope.addThis(node.name, node.expr);
    } else {
      return scope.addVar(node.name, node.expr);
    }
  };

  walk_program = function(node, scope) {
    walk(node.body.statements, scope);
    return node.annotation = {
      type: 'Program'
    };
  };

  walk_block = function(node, scope) {
    var last_annotation, _ref1;
    walk(node.statements, scope);
    last_annotation = (_ref1 = node.statements[node.statements.length - 1]) != null ? _ref1.annotation : void 0;
    return node.annotation = last_annotation;
  };

  walk_return = function(node, scope) {
    var _ref1, _ref2;
    walk(node.expression, scope);
    if (((_ref1 = node.expression) != null ? (_ref2 = _ref1.annotation) != null ? _ref2.type : void 0 : void 0) != null) {
      scope.addReturnable(node.expression.annotation.type);
      return node.annotation = node.expression.annotation;
    }
  };

  walk_binOp = function(node, scope) {
    var left_type, right_type, _ref1, _ref2, _ref3, _ref4;
    walk(node.left, scope);
    walk(node.right, scope);
    left_type = (_ref1 = node.left) != null ? (_ref2 = _ref1.annotation) != null ? _ref2.type : void 0 : void 0;
    right_type = (_ref3 = node.right) != null ? (_ref4 = _ref3.annotation) != null ? _ref4.type : void 0 : void 0;
    if (left_type && right_type) {
      if (left_type === 'String' || right_type === 'String') {
        return node.annotation = {
          type: 'String'
        };
      } else if (left_type === right_type) {
        return node.annotation = {
          type: left_type
        };
      }
    } else {
      return node.annotation = {
        type: 'Any'
      };
    }
  };

  walk_conditional = function(node, scope) {
    var alternate_annotation, annotation, possibilities, type, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    walk(node.condition, scope);
    walk(node.consequent, scope);
    if (node.alternate != null) {
      walk(node.alternate, scope);
    }
    alternate_annotation = (_ref1 = ((_ref2 = node.alternate) != null ? _ref2.annotation : void 0)) != null ? _ref1 : {
      type: 'Undefined'
    };
    possibilities = [];
    _ref4 = [(_ref3 = node.consequent) != null ? _ref3.annotation : void 0, alternate_annotation];
    for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
      annotation = _ref4[_i];
      if (annotation != null) {
        if (((_ref5 = annotation.type) != null ? _ref5.possibilities : void 0) != null) {
          _ref6 = annotation.type.possibilities;
          for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
            type = _ref6[_j];
            possibilities.push(type);
          }
        } else if (annotation.type != null) {
          possibilities.push(annotation.type);
        }
      }
    }
    return node.annotation = {
      type: {
        possibilities: possibilities
      }
    };
  };

  walk_switch = function(node, scope) {
    var alternate_annotation, c, cond, possibilities, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _ref4, _ref5;
    walk(node.expression, scope);
    _ref1 = node.cases;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      c = _ref1[_i];
      _ref2 = c.conditions;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        cond = _ref2[_j];
        walk(c, scope);
      }
      walk(c.consequent, scope);
    }
    walk(node.consequent, scope);
    if (node.alternate != null) {
      walk(node.alternate, scope);
    }
    alternate_annotation = (_ref3 = ((_ref4 = node.alternate) != null ? _ref4.annotation : void 0)) != null ? _ref3 : {
      type: 'Undefined'
    };
    possibilities = [];
    _ref5 = node.cases;
    for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
      c = _ref5[_k];
      if (c.annotation != null) {
        possibilities.push(c.consequent.annotation);
      }
    }
    possibilities.push(alternate_annotation.type);
    return node.annotation = {
      type: {
        possibilities: possibilities
      }
    };
  };

  walk_newOp = function(node, scope) {
    var Type;
    Type = scope.getTypeInScope(node.ctor.data);
    return node.annotation = {
      type: Type != null ? Type.type : void 0
    };
  };

  walk_for = function(node, scope) {
    var err, nop, type, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    walk(node.target, scope);
    if (node.valAssignee != null) {
      scope.addVar(node.valAssignee.data, (_ref1 = ((_ref2 = node.valAssignee) != null ? (_ref3 = _ref2.annotation) != null ? _ref3.type : void 0 : void 0)) != null ? _ref1 : 'Any');
    }
    if (node.keyAssignee != null) {
      scope.addVar(node.keyAssignee.data, (_ref4 = ((_ref5 = node.keyAssignee) != null ? (_ref6 = _ref5.annotation) != null ? _ref6.type : void 0 : void 0)) != null ? _ref4 : 'Any');
    }
    if (node.valAssignee != null) {
      if (((_ref7 = node.target.annotation) != null ? (_ref8 = _ref7.type) != null ? _ref8.array : void 0 : void 0) != null) {
        if (err = scope.checkAcceptableObject(node.valAssignee.annotation.type, node.target.annotation.type.array)) {
          return reporter.add_error(node, err);
        }
      } else if (((_ref9 = node.target) != null ? (_ref10 = _ref9.annotation) != null ? _ref10.type : void 0 : void 0) instanceof Object) {
        if (node.target.annotation.type instanceof Object) {
          _ref11 = node.target.annotation.type;
          for (nop in _ref11) {
            type = _ref11[nop];
            if (err = scope.checkAcceptableObject(node.valAssignee.annotation.type, type)) {
              return reporter.add_error(node, err);
            }
          }
        }
      }
    }
    walk(node.body, scope);
    node.annotation = (_ref12 = node.target) != null ? _ref12.annotation : void 0;
    delete scope._vars[(_ref13 = node.valAssignee) != null ? _ref13.data : void 0];
    return delete scope._vars[(_ref14 = node.keyAssignee) != null ? _ref14.data : void 0];
  };

  walk_classProtoAssignOp = function(node, scope) {
    var left, right, symbol;
    left = node.assignee;
    right = node.expression;
    symbol = left.data;
    walk(left, scope);
    console.log(symbol, scope.getThis(symbol));
    if ((right["instanceof"](CS.Function)) && scope.getThis(symbol)) {
      walk_function(right, scope, scope.getThis(symbol).type);
    } else {
      walk(right, scope);
    }
    symbol = left.data;
    if (right.annotation != null) {
      return scope.addThis(symbol, right.annotation.type);
    }
  };

  walk_assignOp = function(node, scope) {
    var T, err, left, pre_registered_annotation, right, symbol, _ref1, _ref2;
    pre_registered_annotation = node.assignee.annotation;
    left = node.assignee;
    right = node.expression;
    symbol = left.data;
    walk(left, scope);
    if ((typeof right["instanceof"] === "function" ? right["instanceof"](CS.Function) : void 0) && scope.getVarInScope(symbol)) {
      walk_function(right, scope, scope.getVarInScope(symbol).type);
    } else if ((typeof right["instanceof"] === "function" ? right["instanceof"](CS.Function) : void 0) && pre_registered_annotation) {
      walk_function(right, scope, left.annotation.type);
    } else {
      walk(right, scope);
    }
    if (left["instanceof"](CS.MemberAccessOp)) {
      if (left.expression["instanceof"](CS.This)) {
        T = scope.getThis(left.memberName);
        if (T != null) {
          left.annotation = T;
        }
        if (T != null) {
          if (err = scope.checkAcceptableObject(left.annotation.type, right.annotation.type)) {
            return reporter.add_error(node, err);
          }
        }
      } else if ((((_ref1 = left.annotation) != null ? _ref1.type : void 0) != null) && (((_ref2 = right.annotation) != null ? _ref2.type : void 0) != null)) {
        if (left.annotation.type !== 'Any') {
          if (err = scope.checkAcceptableObject(left.annotation.type, right.annotation.type)) {
            return reporter.add_error(node, err);
          }
        }
      }
    } else if (left["instanceof"](CS.Identifier)) {
      symbol = left.data;
      if (scope.getVarInScope(symbol) && pre_registered_annotation) {
        return report.add_error(node, 'double bind: ' + symbol);
      }
      scope.addVar(symbol, left.annotation.type);
      if (left.annotation.type != null) {
        if (left.annotation.type === 'Any') {
          return scope.addVar(symbol, 'Any', true);
        } else {
          if ((right.annotation != null) && (left.annotation != null)) {
            if (err = scope.checkAcceptableObject(left.annotation.type, right.annotation.type)) {
              return reporter.add_error(node, err);
            }
          }
          return scope.addVar(symbol, left.annotation.type);
        }
      }
    } else {
      return scope.addVar(symbol, 'Any');
    }
  };

  walk_primitives = function(node, scope) {
    switch (false) {
      case !node["instanceof"](CS.String):
        return walk_string(node, scope);
      case !node["instanceof"](CS.Bool):
        return walk_bool(node, scope);
      case !node["instanceof"](CS.Numbers):
        return walk_numbers(node, scope);
    }
  };

  walk_string = function(node, scope) {
    return node.annotation != null ? node.annotation : node.annotation = {
      type: 'String',
      primitive: true
    };
  };

  walk_numbers = function(node, scope) {
    return node.annotation != null ? node.annotation : node.annotation = {
      type: 'Number',
      primitive: true
    };
  };

  walk_bool = function(node, scope) {
    return node.annotation != null ? node.annotation : node.annotation = {
      type: 'Boolean',
      primitive: true
    };
  };

  walk_identifier = function(node, scope) {
    var Var;
    if (scope.getVarInScope(node.data)) {
      Var = scope.getVarInScope(node.data);
      return node.annotation = {
        type: Var != null ? Var.type : void 0
      };
    } else {
      return node.annotation != null ? node.annotation : node.annotation = {
        type: 'Any'
      };
    }
  };

  walk_this = function(node, scope) {
    var key, type, val, _ref1;
    type = {};
    _ref1 = scope._this;
    for (key in _ref1) {
      val = _ref1[key];
      type[key] = val.type;
    }
    return node.annotation != null ? node.annotation : node.annotation = {
      type: type
    };
  };

  walk_memberAccess = function(node, scope) {
    var type, _ref1, _ref2;
    if (node["instanceof"](CS.SoakedMemberAccessOp)) {
      walk(node.expression, scope);
      type = scope.extendTypeLiteral((_ref1 = node.expression.annotation) != null ? _ref1.type : void 0);
      if (type != null) {
        return node.annotation = {
          type: {
            possibilities: ['Undefined', type[node.memberName]]
          }
        };
      } else {
        return node.annotation = {
          type: 'Any'
        };
      }
    } else if (node["instanceof"](CS.MemberAccessOp)) {
      walk(node.expression, scope);
      type = scope.extendTypeLiteral((_ref2 = node.expression.annotation) != null ? _ref2.type : void 0);
      if (type != null) {
        return node.annotation = {
          type: type[node.memberName]
        };
      } else {
        return node.annotation = {
          type: 'Any'
        };
      }
    }
  };

  walk_arrayInializer = function(node, scope) {
    var _ref1;
    walk(node.members, scope);
    return node.annotation != null ? node.annotation : node.annotation = {
      type: {
        array: (_ref1 = node.members) != null ? _ref1.map(function(m) {
          var _ref2;
          return (_ref2 = m.annotation) != null ? _ref2.type : void 0;
        }) : void 0
      }
    };
  };

  walk_range = function(node, scope) {
    return node.annotation = {
      type: {
        array: 'Number'
      }
    };
  };

  walk_objectInitializer = function(node, scope) {
    var expression, key, nextScope, obj, _i, _len, _ref1, _ref2, _ref3;
    obj = {};
    nextScope = new Scope(scope);
    nextScope.name = 'object';
    _ref1 = node.members;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      _ref2 = _ref1[_i], expression = _ref2.expression, key = _ref2.key;
      if (!(key != null)) {
        continue;
      }
      walk(expression, nextScope);
      obj[key.data] = (_ref3 = expression.annotation) != null ? _ref3.type : void 0;
    }
    return node.annotation != null ? node.annotation : node.annotation = {
      type: obj
    };
  };

  walk_class = function(node, scope) {
    var classScope, constructorScope, fname, obj, param, statement, val, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    classScope = new ClassScope(scope);
    if (((_ref1 = node.body) != null ? _ref1.statements : void 0) != null) {
      _ref2 = node.body.statements;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        statement = _ref2[_i];
        if (statement.type === 'vardef') {
          walk_vardef(statement, classScope);
        }
      }
    }
    if (node.ctor != null) {
      constructorScope = new FunctionScope(classScope);
      constructorScope._this = classScope._this;
      if (node.ctor.expression.parameters != null) {
        _ref3 = node.ctor.expression.parameters;
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          param = _ref3[_j];
          walk(param, classScope);
        }
      }
      if (((_ref4 = node.ctor.expression.body) != null ? _ref4.statements : void 0) != null) {
        _ref5 = node.ctor.expression.body.statements;
        for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
          statement = _ref5[_k];
          walk(statement, constructorScope);
        }
      }
    }
    if (((_ref6 = node.body) != null ? _ref6.statements : void 0) != null) {
      _ref7 = node.body.statements;
      for (_l = 0, _len3 = _ref7.length; _l < _len3; _l++) {
        statement = _ref7[_l];
        if (statement.type !== 'vardef') {
          walk(statement, classScope);
        }
      }
    }
    if ((_ref8 = node.nameAssignee) != null ? _ref8.data : void 0) {
      obj = {};
      _ref9 = classScope._this;
      for (fname in _ref9) {
        val = _ref9[fname];
        obj[fname] = val.type;
      }
      return scope.addType(node.nameAssignee.data, obj);
    }
  };

  walk_function = function(node, scope, predef) {
    var err, functionScope, index, last_expr, param, _args_, _i, _j, _len, _len1, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref19, _ref2, _ref20, _ref21, _ref22, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (predef == null) {
      predef = null;
    }
    _args_ = (_ref1 = node.parameters) != null ? _ref1.map(function(param) {
      var _ref2, _ref3;
      return (_ref2 = (_ref3 = param.annotation) != null ? _ref3.type : void 0) != null ? _ref2 : 'Any';
    }) : void 0;
    node.annotation.type._args_ = _args_;
    functionScope = new Scope(scope);
    functionScope._name_ = 'function';
    if (scope instanceof ClassScope) {
      functionScope._this = scope._this;
    }
    if (node.parameters != null) {
      if (predef) {
        node.annotation.type = predef;
        _ref2 = node.parameters;
        for (index = _i = 0, _len = _ref2.length; _i < _len; index = ++_i) {
          param = _ref2[index];
          functionScope.addVar(param.data, (_ref3 = (_ref4 = predef._args_) != null ? _ref4[index] : void 0) != null ? _ref3 : 'Any');
        }
      } else {
        _ref5 = node.parameters;
        for (index = _j = 0, _len1 = _ref5.length; _j < _len1; index = ++_j) {
          param = _ref5[index];
          functionScope.addVar(param.data, (_ref6 = param != null ? (_ref7 = param.annotation) != null ? _ref7.type : void 0 : void 0) != null ? _ref6 : 'Any');
        }
      }
    }
    walk(node.body, functionScope);
    if (((_ref8 = node.annotation) != null ? (_ref9 = _ref8.type) != null ? _ref9._return_ : void 0 : void 0) !== 'Any') {
      last_expr = ((_ref10 = node.body) != null ? (_ref11 = _ref10.statements) != null ? _ref11.length : void 0 : void 0) ? (_ref12 = node.body.statements) != null ? _ref12[((_ref13 = node.body) != null ? (_ref14 = _ref13.statements) != null ? _ref14.length : void 0 : void 0) - 1] : void 0 : node.body;
      if (err = scope.checkAcceptableObject((_ref15 = node.annotation) != null ? _ref15.type._return_ : void 0, last_expr != null ? (_ref16 = last_expr.annotation) != null ? _ref16.type : void 0 : void 0)) {
        return reporter.add_error(node, err);
      }
    } else {
      last_expr = ((_ref17 = node.body) != null ? (_ref18 = _ref17.statements) != null ? _ref18.length : void 0 : void 0) ? (_ref19 = node.body.statements) != null ? _ref19[((_ref20 = node.body) != null ? (_ref21 = _ref20.statements) != null ? _ref21.length : void 0 : void 0) - 1] : void 0 : node.body;
      if (node.annotation != null) {
        return node.annotation.type._return_ = last_expr != null ? (_ref22 = last_expr.annotation) != null ? _ref22.type : void 0 : void 0;
      }
    }
  };

  walk_functionApplication = function(node, scope) {
    var arg, err, _args_, _i, _len, _ref1, _ref2, _ref3, _ref4;
    _ref1 = node["arguments"];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      arg = _ref1[_i];
      walk(arg, scope);
    }
    walk(node["function"], scope);
    node.annotation = {
      type: ((_ref2 = node["function"].annotation) != null ? (_ref3 = _ref2.type) != null ? _ref3._return_ : void 0 : void 0)
    };
    if (node["function"].annotation) {
      _args_ = (_ref4 = node["arguments"]) != null ? _ref4.map(function(arg) {
        var _ref5;
        return (_ref5 = arg.annotation) != null ? _ref5.type : void 0;
      }) : void 0;
      if (err = scope.checkAcceptableObject(node["function"].annotation.type, {
        _args_: _args_ != null ? _args_ : [],
        _return_: 'Any'
      })) {
        return reporter.add_error(node, err);
      }
    }
  };

  walk = function(node, scope) {
    var s, _i, _len, _results;
    console.log('---', node != null ? node.className : void 0, '---');
    switch (false) {
      case !(node == null):
        break;
      case node.length == null:
        _results = [];
        for (_i = 0, _len = node.length; _i < _len; _i++) {
          s = node[_i];
          _results.push(walk(s, scope));
        }
        return _results;
        break;
      case node.type !== 'struct':
        return walk_struct(node, scope);
      case node.type !== 'vardef':
        return walk_vardef(node, scope);
      case !node["instanceof"](CS.Program):
        return walk_program(node, scope);
      case !node["instanceof"](CS.Block):
        return walk_block(node, scope);
      case !node["instanceof"](CS.Return):
        return walk_return(node, scope);
      case !node["instanceof"](CS.NewOp):
        return walk_newOp(node, scope);
      case !(node["instanceof"](CS.PlusOp) || node["instanceof"](CS.MultiplyOp) || node["instanceof"](CS.DivideOp) || node["instanceof"](CS.SubtractOp)):
        return walk_binOp(node, scope);
      case !node["instanceof"](CS.Switch):
        return walk_switch(node, scope);
      case !node["instanceof"](CS.Conditional):
        return walk_conditional(node, scope);
      case !((node["instanceof"](CS.ForIn)) || (node["instanceof"](CS.ForOf))):
        return walk_for(node, scope);
      case !node["instanceof"](CS.Primitives):
        return walk_primitives(node, scope);
      case !node["instanceof"](CS.This):
        return walk_this(node, scope);
      case !node["instanceof"](CS.Identifier):
        return walk_identifier(node, scope);
      case !node["instanceof"](CS.ClassProtoAssignOp):
        return walk_classProtoAssignOp(node, scope);
      case !node["instanceof"](CS.MemberAccessOps):
        return walk_memberAccess(node, scope);
      case !node["instanceof"](CS.ArrayInitialiser):
        return walk_arrayInializer(node, scope);
      case !node["instanceof"](CS.Range):
        return walk_range(node, scope);
      case !node["instanceof"](CS.ObjectInitialiser):
        return walk_objectInitializer(node, scope);
      case !node["instanceof"](CS.Class):
        return walk_class(node, scope);
      case !node["instanceof"](CS.Function):
        return walk_function(node, scope);
      case !node["instanceof"](CS.FunctionApplication):
        return walk_functionApplication(node, scope);
      case !node["instanceof"](CS.AssignOp):
        return walk_assignOp(node, scope);
    }
  };

  module.exports = {
    checkNodes: checkNodes
  };

}).call(this);
