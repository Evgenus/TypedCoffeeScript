// Generated by CoffeeScript 1.6.3
(function() {
  var CS, Scope, TypeSymbol, VarSymbol, checkNodes, console, g, initializeGlobalTypes, pj, render, walk, walk_arrayInializer, walk_assignOp, walk_binOp, walk_block, walk_bool, walk_class, walk_classProtoAssignOp, walk_conditional, walk_for, walk_function, walk_functionApplication, walk_identifier, walk_memberAccess, walk_newOp, walk_numbers, walk_objectInitializer, walk_primitives, walk_program, walk_range, walk_return, walk_string, walk_struct, walk_switch, _ref;

  console = {
    log: function() {}
  };

  pj = (function() {
    try {
      return require('prettyjson');
    } catch (_error) {}
  })();

  render = function(obj) {
    return pj != null ? pj.render(obj) : void 0;
  };

  CS = require('./nodes');

  _ref = require('./types'), initializeGlobalTypes = _ref.initializeGlobalTypes, VarSymbol = _ref.VarSymbol, TypeSymbol = _ref.TypeSymbol, Scope = _ref.Scope;

  g = typeof window !== "undefined" && window !== null ? window : global;

  checkNodes = function(cs_ast) {
    var i, root, _i, _len, _ref1, _ref2;
    if (((_ref1 = cs_ast.body) != null ? _ref1.statements : void 0) == null) {
      return;
    }
    if (g._root_) {
      root = g._root_;
    } else {
      g._root_ = root = new Scope;
      root.name = 'root';
      _ref2 = ['global', 'exports', 'module'];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        i = _ref2[_i];
        root.addVar(i, 'Any', true);
      }
      initializeGlobalTypes(root);
    }
    walk(cs_ast, root);
    Scope.dump(root);
    return root;
  };

  walk_struct = function(node, scope) {
    if (node.name instanceof Object) {
      return scope.addType(node.name.base, node.expr, node.name.templates);
    } else {
      return scope.addType(node.name, node.expr);
    }
  };

  walk_program = function(node, scope) {
    walk(node.body.statements, scope);
    return node.annotation = {
      type: 'Program'
    };
  };

  walk_block = function(node, scope) {
    var last_annotation, _ref1;
    walk(node.statements, scope);
    last_annotation = (_ref1 = node.statements[node.statements.length - 1]) != null ? _ref1.annotation : void 0;
    return node.annotation = last_annotation;
  };

  walk_return = function(node, scope) {
    var _ref1, _ref2;
    walk(node.expression, scope);
    if (((_ref1 = node.expression) != null ? (_ref2 = _ref1.annotation) != null ? _ref2.type : void 0 : void 0) != null) {
      scope.addReturnable(node.expression.annotation.type);
      return node.annotation = node.expression.annotation;
    }
  };

  walk_binOp = function(node, scope) {
    var left_type, right_type, _ref1, _ref2, _ref3, _ref4;
    walk(node.left, scope);
    walk(node.right, scope);
    left_type = (_ref1 = node.left) != null ? (_ref2 = _ref1.annotation) != null ? _ref2.type : void 0 : void 0;
    right_type = (_ref3 = node.right) != null ? (_ref4 = _ref3.annotation) != null ? _ref4.type : void 0 : void 0;
    if (left_type && right_type) {
      if (left_type === 'String' || right_type === 'String') {
        return node.annotation = {
          type: 'String'
        };
      } else if (left_type === right_type) {
        return node.annotation = {
          type: left_type
        };
      }
    } else {
      return node.annotation = {
        type: 'Any'
      };
    }
  };

  walk_conditional = function(node, scope) {
    var alternate_annotation, annotation, possibilities, type, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    walk(node.condition, scope);
    walk(node.consequent, scope);
    if (node.alternate != null) {
      walk(node.alternate, scope);
    }
    alternate_annotation = (_ref1 = ((_ref2 = node.alternate) != null ? _ref2.annotation : void 0)) != null ? _ref1 : {
      type: 'Undefined'
    };
    possibilities = [];
    _ref4 = [(_ref3 = node.consequent) != null ? _ref3.annotation : void 0, alternate_annotation];
    for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
      annotation = _ref4[_i];
      if (annotation != null) {
        if (((_ref5 = annotation.type) != null ? _ref5.possibilities : void 0) != null) {
          _ref6 = annotation.type.possibilities;
          for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {
            type = _ref6[_j];
            possibilities.push(type);
          }
        } else if (annotation.type != null) {
          possibilities.push(annotation.type);
        }
      }
    }
    return node.annotation = {
      type: {
        possibilities: possibilities
      }
    };
  };

  walk_switch = function(node, scope) {
    var alternate_annotation, c, cond, possibilities, _i, _j, _k, _len, _len1, _len2, _ref1, _ref2, _ref3, _ref4, _ref5;
    walk(node.expression, scope);
    _ref1 = node.cases;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      c = _ref1[_i];
      _ref2 = c.conditions;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        cond = _ref2[_j];
        walk(c, scope);
      }
      walk(c.consequent, scope);
    }
    walk(node.consequent, scope);
    if (node.alternate != null) {
      walk(node.alternate, scope);
    }
    alternate_annotation = (_ref3 = ((_ref4 = node.alternate) != null ? _ref4.annotation : void 0)) != null ? _ref3 : {
      type: 'Undefined'
    };
    possibilities = [];
    _ref5 = node.cases;
    for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
      c = _ref5[_k];
      if (c.annotation != null) {
        possibilities.push(c.consequent.annotation);
      }
    }
    possibilities.push(alternate_annotation.type);
    return node.annotation = {
      type: {
        possibilities: possibilities
      }
    };
  };

  walk_newOp = function(node, scope) {
    return node.annotation = {
      type: scope.getTypeInScope(node.ctor.data)
    };
  };

  walk_for = function(node, scope) {
    var nop, type, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    walk(node.target, scope);
    if (node.valAssignee != null) {
      scope.addVar(node.valAssignee.data, (_ref1 = ((_ref2 = node.valAssignee) != null ? (_ref3 = _ref2.annotation) != null ? _ref3.type : void 0 : void 0)) != null ? _ref1 : 'Any');
    }
    if (node.keyAssignee != null) {
      scope.addVar(node.keyAssignee.data, (_ref4 = ((_ref5 = node.keyAssignee) != null ? (_ref6 = _ref5.annotation) != null ? _ref6.type : void 0 : void 0)) != null ? _ref4 : 'Any');
    }
    if (node.valAssignee != null) {
      if (((_ref7 = node.target.annotation) != null ? (_ref8 = _ref7.type) != null ? _ref8.array : void 0 : void 0) != null) {
        scope.checkAcceptableObject(node.valAssignee.annotation.type, node.target.annotation.type.array);
      } else if (((_ref9 = node.target) != null ? (_ref10 = _ref9.annotation) != null ? _ref10.type : void 0 : void 0) instanceof Object) {
        if (node.target.annotation.type instanceof Object) {
          _ref11 = node.target.annotation.type;
          for (nop in _ref11) {
            type = _ref11[nop];
            scope.checkAcceptableObject(node.valAssignee.annotation.type, type);
          }
        }
      }
    }
    walk(node.body, scope);
    node.annotation = (_ref12 = node.body) != null ? _ref12.annotation : void 0;
    delete scope._vars[(_ref13 = node.valAssignee) != null ? _ref13.data : void 0];
    return delete scope._vars[(_ref14 = node.keyAssignee) != null ? _ref14.data : void 0];
  };

  walk_classProtoAssignOp = function(node, scope) {
    var left, right, symbol;
    left = node.assignee;
    right = node.expression;
    walk(right, scope);
    walk(left, scope);
    symbol = left.data;
    if (right.annotation != null) {
      return scope.addThis(symbol, right.annotation.type);
    }
  };

  walk_assignOp = function(node, scope) {
    var left, pre_registered_annotation, right, symbol, _ref1, _ref2;
    pre_registered_annotation = node.assignee.annotation;
    left = node.assignee;
    right = node.expression;
    walk(right, scope);
    walk(left, scope);
    symbol = left.data;
    if (left["instanceof"](CS.Identifier)) {
      symbol = left.data;
      if (scope.getVarInScope(symbol) && pre_registered_annotation) {
        throw new Error('double bind: ' + symbol);
      }
      scope.addVar(symbol, left.annotation.type);
      if (left.annotation.type != null) {
        if (left.annotation.type === 'Any') {
          return scope.addVar(symbol, 'Any', true);
        } else if (right["instanceof"](CS.ForIn)) {
          return scope.checkAcceptableObject(left.annotation.type.array, right.annotation.type);
        } else if ((left.annotation.type.args != null) && (right.annotation.type.args != null)) {
          scope.checkFunctionLiteral(left.annotation.type, right.annotation.type);
          return scope.addVar(symbol, left.annotation.type);
        } else {
          if ((right.annotation != null) && (left.annotation != null)) {
            scope.checkAcceptableObject(left.annotation.type, right.annotation.type);
          }
          return scope.addVar(symbol, left.annotation.type);
        }
      }
    } else if (left["instanceof"](CS.MemberAccessOp)) {
      if (left.expression.raw === '@') {
        return;
      }
      if ((((_ref1 = left.annotation) != null ? _ref1.type : void 0) != null) && (((_ref2 = right.annotation) != null ? _ref2.type : void 0) != null)) {
        if (left.annotation.type !== 'Any') {
          return scope.checkAcceptableObject(left.annotation.type, right.annotation.type);
        }
      }
    } else {
      return scope.addVar(symbol, 'Any');
    }
  };

  walk_primitives = function(node, scope) {
    switch (false) {
      case !node["instanceof"](CS.String):
        return walk_string(node, scope);
      case !node["instanceof"](CS.Bool):
        return walk_bool(node, scope);
      case !node["instanceof"](CS.Numbers):
        return walk_numbers(node, scope);
    }
  };

  walk_string = function(node, scope) {
    return node.annotation != null ? node.annotation : node.annotation = {
      type: 'String',
      primitive: true
    };
  };

  walk_numbers = function(node, scope) {
    return node.annotation != null ? node.annotation : node.annotation = {
      type: 'Number',
      primitive: true
    };
  };

  walk_bool = function(node, scope) {
    return node.annotation != null ? node.annotation : node.annotation = {
      type: 'Boolean',
      primitive: true
    };
  };

  walk_identifier = function(node, scope) {
    if (scope.getVarInScope(node.data)) {
      return node.annotation = {
        type: scope.getVarInScope(node.data)
      };
    } else {
      return node.annotation != null ? node.annotation : node.annotation = {
        type: 'Any'
      };
    }
  };

  walk_memberAccess = function(node, scope) {
    var type, _ref1, _ref2;
    if (node["instanceof"](CS.SoakedMemberAccessOp)) {
      walk(node.expression, scope);
      type = scope.extendTypeLiteral((_ref1 = node.expression.annotation) != null ? _ref1.type : void 0);
      if (type != null) {
        return node.annotation = {
          type: {
            possibilities: ['Undefined', type[node.memberName]]
          }
        };
      } else {
        return node.annotation = {
          type: 'Any'
        };
      }
    } else if (node["instanceof"](CS.MemberAccessOp)) {
      walk(node.expression, scope);
      type = scope.extendTypeLiteral((_ref2 = node.expression.annotation) != null ? _ref2.type : void 0);
      if (type != null) {
        return node.annotation = {
          type: type[node.memberName]
        };
      } else {
        return node.annotation = {
          type: 'Any'
        };
      }
    }
  };

  walk_arrayInializer = function(node, scope) {
    var _ref1;
    walk(node.members, scope);
    return node.annotation != null ? node.annotation : node.annotation = {
      type: {
        array: (_ref1 = node.members) != null ? _ref1.map(function(m) {
          var _ref2;
          return (_ref2 = m.annotation) != null ? _ref2.type : void 0;
        }) : void 0
      }
    };
  };

  walk_range = function(node, scope) {
    return node.annotation = {
      type: {
        array: 'Number'
      }
    };
  };

  walk_objectInitializer = function(node, scope) {
    var expression, key, nextScope, obj, _i, _len, _ref1, _ref2, _ref3;
    obj = {};
    nextScope = new Scope(scope);
    nextScope.name = 'object';
    _ref1 = node.members;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      _ref2 = _ref1[_i], expression = _ref2.expression, key = _ref2.key;
      if (!(key != null)) {
        continue;
      }
      walk(expression, nextScope);
      obj[key.data] = (_ref3 = expression.annotation) != null ? _ref3.type : void 0;
    }
    return node.annotation != null ? node.annotation : node.annotation = {
      type: obj
    };
  };

  walk_class = function(node, scope) {
    var classScope, fname, obj, val, _ref1, _ref2;
    classScope = new Scope(scope);
    walk(node.body, classScope);
    if ((_ref1 = node.nameAssignee) != null ? _ref1.data : void 0) {
      obj = {};
      _ref2 = classScope._this;
      for (fname in _ref2) {
        val = _ref2[fname];
        obj[fname] = val.type;
      }
      return scope.addType(node.nameAssignee.data, obj);
    }
  };

  walk_function = function(node, scope) {
    var args, functionScope, last_expr, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    args = (_ref1 = node.parameters) != null ? _ref1.map(function(param) {
      var _ref2, _ref3;
      return (_ref2 = (_ref3 = param.annotation) != null ? _ref3.type : void 0) != null ? _ref2 : 'Any';
    }) : void 0;
    node.annotation.type.args = args;
    functionScope = new Scope(scope);
    functionScope.name = 'function';
    if ((_ref2 = node.parameters) != null) {
      _ref2.map(function(param) {
        var _ref3, _ref4;
        try {
          return typeof functionScope.addVar === "function" ? functionScope.addVar(param.data, (_ref3 = (_ref4 = param.annotation) != null ? _ref4.type : void 0) != null ? _ref3 : 'Any') : void 0;
        } catch (_error) {
          return 'ignore but brake on somewhere. why?';
        }
      });
    }
    walk(node.body, functionScope);
    if (((_ref3 = node.annotation) != null ? (_ref4 = _ref3.type) != null ? _ref4.returns : void 0 : void 0) !== 'Any') {
      last_expr = ((_ref5 = node.body) != null ? (_ref6 = _ref5.statements) != null ? _ref6.length : void 0 : void 0) ? (_ref7 = node.body.statements) != null ? _ref7[((_ref8 = node.body) != null ? (_ref9 = _ref8.statements) != null ? _ref9.length : void 0 : void 0) - 1] : void 0 : node.body;
      return scope.checkAcceptableObject(node.annotation.type.returns, (_ref10 = last_expr.annotation) != null ? _ref10.type : void 0);
    } else {
      last_expr = ((_ref11 = node.body) != null ? (_ref12 = _ref11.statements) != null ? _ref12.length : void 0 : void 0) ? (_ref13 = node.body.statements) != null ? _ref13[((_ref14 = node.body) != null ? (_ref15 = _ref14.statements) != null ? _ref15.length : void 0 : void 0) - 1] : void 0 : node.body;
      if (node.annotation != null) {
        return node.annotation.type.returns = last_expr != null ? (_ref16 = last_expr.annotation) != null ? _ref16.type : void 0 : void 0;
      }
    }
  };

  walk_functionApplication = function(node, scope) {
    var arg, args, _i, _len, _ref1, _ref2, _ref3, _ref4;
    _ref1 = node["arguments"];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      arg = _ref1[_i];
      walk(arg, scope);
    }
    walk(node["function"], scope);
    node.annotation = {
      type: ((_ref2 = node["function"].annotation) != null ? (_ref3 = _ref2.type) != null ? _ref3.returns : void 0 : void 0)
    };
    if (node["function"].annotation) {
      args = (_ref4 = node["arguments"]) != null ? _ref4.map(function(arg) {
        var _ref5;
        return (_ref5 = arg.annotation) != null ? _ref5.type : void 0;
      }) : void 0;
      return scope.checkFunctionLiteral(node["function"].annotation.type, {
        args: args != null ? args : [],
        returns: 'Any'
      });
    }
  };

  walk = function(node, scope) {
    var s, _i, _len, _results;
    console.log('---', node != null ? node.className : void 0, '---');
    switch (false) {
      case !(node == null):
        break;
      case node.length == null:
        _results = [];
        for (_i = 0, _len = node.length; _i < _len; _i++) {
          s = node[_i];
          _results.push(walk(s, scope));
        }
        return _results;
        break;
      case node.type !== 'struct':
        return walk_struct(node, scope);
      case !node["instanceof"](CS.Program):
        return walk_program(node, scope);
      case !node["instanceof"](CS.Block):
        return walk_block(node, scope);
      case !node["instanceof"](CS.Return):
        return walk_return(node, scope);
      case !node["instanceof"](CS.NewOp):
        return walk_newOp(node, scope);
      case !(node["instanceof"](CS.PlusOp) || node["instanceof"](CS.MultiplyOp) || node["instanceof"](CS.DivideOp) || node["instanceof"](CS.SubtractOp)):
        return walk_binOp(node, scope);
      case !node["instanceof"](CS.Switch):
        return walk_switch(node, scope);
      case !node["instanceof"](CS.Conditional):
        return walk_conditional(node, scope);
      case !((node["instanceof"](CS.ForIn)) || (node["instanceof"](CS.ForOf))):
        return walk_for(node, scope);
      case !node["instanceof"](CS.Primitives):
        return walk_primitives(node, scope);
      case !node["instanceof"](CS.Identifier):
        return walk_identifier(node, scope);
      case !node["instanceof"](CS.ClassProtoAssignOp):
        return walk_classProtoAssignOp(node, scope);
      case !node["instanceof"](CS.MemberAccessOps):
        return walk_memberAccess(node, scope);
      case !node["instanceof"](CS.ArrayInitialiser):
        return walk_arrayInializer(node, scope);
      case !node["instanceof"](CS.Range):
        return walk_range(node, scope);
      case !node["instanceof"](CS.ObjectInitialiser):
        return walk_objectInitializer(node, scope);
      case !node["instanceof"](CS.Class):
        return walk_class(node, scope);
      case !node["instanceof"](CS.Function):
        return walk_function(node, scope);
      case !node["instanceof"](CS.FunctionApplication):
        return walk_functionApplication(node, scope);
      case !node["instanceof"](CS.AssignOp):
        return walk_assignOp(node, scope);
    }
  };

  module.exports = {
    checkNodes: checkNodes
  };

}).call(this);
