// Generated by CoffeeScript 2.0.0-beta8-dev
var checkNodes, console, CS, guess_expr_type, initializeGlobalTypes, Scope, TypeSymbol, VarSymbol, walk;
console = {
  log: function () {
  }
};
CS = require('./nodes');
guess_expr_type = function (expr) {
  var member, obj;
  if (!(null != expr))
    return;
  if (null != expr.members) {
    obj = {};
    for (var i$ = 0, length$ = expr.members.length; i$ < length$; ++i$) {
      member = expr.members[i$];
      if (!(null != member.key))
        continue;
      obj[member.key.data] = guess_expr_type(member.expression);
    }
    return obj;
  }
  if (typeof expr.data === 'number') {
    return 'Number';
  } else if (typeof expr.data === 'string') {
    return 'String';
  } else if (typeof expr.data === 'boolean') {
    return 'Boolean';
  } else if (null != expr.parameters && null != expr.body) {
    return 'Function';
  } else {
    return 'Any';
  }
};
VarSymbol = function () {
  function VarSymbol(param$) {
    var cache$;
    {
      cache$ = param$;
      this.type = cache$.type;
      this.implicit = cache$.implicit;
    }
  }
  return VarSymbol;
}();
TypeSymbol = function () {
  function TypeSymbol(param$) {
    var cache$;
    {
      cache$ = param$;
      this.type = cache$.type;
      this['instanceof'] = cache$['instanceof'];
    }
    if (null != this['instanceof'])
      this['instanceof'];
    else
      this['instanceof'] = function (t) {
        return t instanceof this.constructor;
      };
  }
  return TypeSymbol;
}();
Scope = function () {
  function Scope(param$) {
    if (null == param$)
      param$ = null;
    this.parent = param$;
    if (null != this.parent)
      this.parent.nodes.push(this);
    this.name = '';
    this.nodes = [];
    this._vars = {};
    this._types = {};
    this._this = null;
  }
  Scope.prototype.setType = function (symbol, type) {
    return this._types[symbol] = new TypeSymbol({ type: type });
  };
  Scope.prototype.setTypeObject = function (symbol, type_object) {
    return this._types[symbol] = type_object;
  };
  Scope.prototype.getType = function (symbol) {
    return null != (null != this._types[symbol] ? this._types[symbol].type : void 0) ? null != this._types[symbol] ? this._types[symbol].type : void 0 : void 0;
  };
  Scope.prototype.getTypeInScope = function (symbol) {
    return this.getType(symbol) || (null != this.parent ? this.parent.getTypeInScope(symbol) : void 0) || void 0;
  };
  Scope.prototype.setVar = function (symbol, type, implicit) {
    if (null == implicit)
      implicit = true;
    return this._vars[symbol] = new VarSymbol({
      type: type,
      implicit: implicit
    });
  };
  Scope.prototype.getVar = function (symbol) {
    return null != (null != this._vars[symbol] ? this._vars[symbol].type : void 0) ? null != this._vars[symbol] ? this._vars[symbol].type : void 0 : void 0;
  };
  Scope.prototype.getVarInScope = function (symbol) {
    return this.getVar(symbol) || (null != this.parent ? this.parent.getVarInScope(symbol) : void 0) || void 0;
  };
  Scope.dump = function (node, prefix) {
    var key, val;
    if (null == prefix)
      prefix = '';
    console.log(prefix + ('[' + node.name + ']'));
    for (key in node._vars) {
      val = node._vars[key];
      console.log(prefix, ' +', key, '::', val);
    }
    return function (accum$) {
      var next;
      for (var i$ = 0, length$ = node.nodes.length; i$ < length$; ++i$) {
        next = node.nodes[i$];
        accum$.push(Scope.dump(next, prefix + '  '));
      }
      return accum$;
    }.call(this, []);
  };
  Scope.prototype.extendTypeLiteral = function (object_or_name) {
    var key, obj, str, val;
    switch (typeof object_or_name) {
    case 'object':
      obj = object_or_name;
      for (key in obj) {
        val = obj[key];
        switch (typeof validate) {
        case 'object':
          obj[key] = this.extendTypeLiteral(val);
          break;
        case 'string':
          obj[key] = this.getTypeInScope(val);
        }
      }
      return obj;
    case 'string':
      str = object_or_name;
      return this.getTypeInScope(str);
    }
  };
  return Scope;
}();
initializeGlobalTypes = function (node) {
  node.setTypeObject('String', new TypeSymbol({
    type: 'String',
    'instanceof': function (expr) {
      return typeof expr.data === 'string';
    }
  }));
  node.setTypeObject('Number', new TypeSymbol({
    type: 'Number',
    'instanceof': function (expr) {
      return typeof expr.data === 'number';
    }
  }));
  node.setTypeObject('Boolean', new TypeSymbol({
    type: 'Boolean',
    'instanceof': function (expr) {
      return typeof expr.data === 'boolean';
    }
  }));
  node.setTypeObject('Object', new TypeSymbol({
    type: 'Object',
    'instanceof': function (expr) {
      return typeof expr.data === 'object';
    }
  }));
  return node.setTypeObject('Any', new TypeSymbol({
    type: 'Any',
    'instanceof': function (expr) {
      return true;
    }
  }));
};
checkNodes = function (cs_ast) {
  var i, root;
  if (!(null != (null != cs_ast.body ? cs_ast.body.statements : void 0)))
    return;
  console.log(cs_ast.body.statements);
  console.log('=====================');
  root = new Scope;
  root.name = 'root';
  for (var cache$ = [
        'global',
        'exports',
        'Module',
        'module'
      ], i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
    i = cache$[i$];
    root.setVar(i, 'Any', true);
  }
  initializeGlobalTypes(root);
  walk(cs_ast.body.statements, root);
  return Scope.dump(root);
};
walk = function (node, currentScope) {
  var assigning, expected, infered, key, left, member, registered, right, scope, symbol, typeobj, val;
  switch (false) {
  case !(node === void 0):
    return;
  case !(null != node.length):
    return node.forEach(function (s) {
      return walk(s, currentScope);
    });
  case !(node.type === 'struct'):
    return currentScope.setType(node.name, node.expr);
  case !node['instanceof'](CS.Class):
    return walk(node.body.statements, new Scope(currentScope));
  case !node['instanceof'](CS.Function):
    scope = new Scope(currentScope);
    scope.name = '-lambda-';
    node.parameters.map(function (param) {
      return scope.setVar(param.data, null != (null != param.annotation ? param.annotation.type : void 0) ? null != param.annotation ? param.annotation.type : void 0 : 'Any');
    });
    return walk(null != node.body ? node.body.statements : void 0, scope);
  case !node['instanceof'](CS.FunctionApplication):
    return walk(node['arguments'], currentScope);
  case !node['instanceof'](CS.AssignOp):
    left = node.assignee;
    right = node.expression;
    if (null != left.memberName) {
      symbol = left.expression.data;
      registered = currentScope.getVarInScope(symbol);
      if (!(null != registered))
        return;
      expected = registered[left.memberName];
      infered = guess_expr_type(right);
      if (null != expected && expected === infered || registered === 'Any') {
        '';
      } else {
        throw new Error("'" + symbol + "' is expected to " + registered + ' (indeed ' + infered + ') at member access');
      }
    }
    symbol = left.data;
    registered = currentScope.getVarInScope(symbol);
    infered = guess_expr_type(right);
    assigning = null != left.annotation ? currentScope.extendTypeLiteral(left.annotation.type) : void 0;
    if (null != assigning && null != registered) {
      throw new Error('double bind', symbol);
    } else if (right['instanceof'](CS.FunctionApplication)) {
      expected = currentScope.getVarInScope(right['function'].data);
      if (expected === void 0) {
        return currentScope.setVar(symbol, 'Any');
      } else if (assigning === (null != expected ? expected.returns : void 0)) {
        return currentScope.setVar(symbol, assigning);
      } else {
        throw new Error("'" + symbol + "' is expected to " + assigning + ' indeed ' + expected + ', by function call');
      }
    } else if (null != registered) {
      if (symbol === 'toString')
        return;
      if (!(registered === infered || registered === 'Any'))
        throw new Error("'" + symbol + "' is expected to " + registered + ' indeed ' + infered + ', by assignee');
    } else if (assigning) {
      if (assigning === 'Any') {
        return currentScope.setVar(symbol, 'Any');
      } else if (left.annotation.type.type === 'Function') {
        return currentScope.setVar(symbol, left.annotation.type);
      } else if (typeof assigning === 'object') {
        typeobj = guess_expr_type(right);
        for (key in assigning) {
          val = assigning[key];
          if (typeobj[key] !== val)
            throw new Error("'" + key + "' is expected to " + typeobj[key] + ' indeed ' + val);
        }
        for (var i$ = 0, length$ = right.members.length; i$ < length$; ++i$) {
          member = right.members[i$];
          walk(member.expression, new Scope(currentScope));
        }
        return currentScope.setVar(symbol, left.annotation.type);
      } else if (assigning === infered) {
        currentScope.setVar(symbol, left.annotation.type);
        return walk(right, currentScope);
      } else {
        if (symbol === 'toString')
          return;
        throw new Error("'" + symbol + "' is expected to " + left.annotation.type + ' indeed ' + infered);
      }
    } else {
      currentScope.setVar(symbol, 'Any');
      return walk(right, currentScope);
    }
  }
};
module.exports = { checkNodes: checkNodes };
