// Generated by CoffeeScript 2.0.0-beta8-dev
var checkAcceptableObject, checkNodes, concat, console, CS, first, initializeGlobalTypes, last, map, pj, render, Scope, TypeSymbol, VarSymbol, walk;
console = {
  log: function () {
  }
};
pj = function () {
  try {
    return require('prettyjson');
  } catch (e$) {
    return;
  }
}.call(this);
render = function (obj) {
  if (null != pj)
    return pj.render(obj);
};
cache$ = require('./functional-helpers');
first = cache$.first;
last = cache$.last;
map = cache$.map;
concat = cache$.concat;
CS = require('./nodes');
checkNodes = function (cs_ast) {
  var i, root;
  if (!(null != (null != cs_ast.body ? cs_ast.body.statements : void 0)))
    return;
  console.log('AST ==================');
  console.log('================== AST');
  root = new Scope;
  root.name = 'root';
  for (var cache$1 = [
        'global',
        'exports',
        'module'
      ], i$ = 0, length$ = cache$1.length; i$ < length$; ++i$) {
    i = cache$1[i$];
    root.addVar(i, 'Any', true);
  }
  initializeGlobalTypes(root);
  walk(cs_ast.body.statements, root);
  console.log('scope =====================');
  Scope.dump(root);
  console.log('================== Scope');
  return console.log('finish ================== checkNodes');
};
checkAcceptableObject = function (left, right) {
  console.log(left, right);
  if (typeof left === 'string' && typeof right === 'string') {
    if (left === right || left === 'Any' || right === 'Any') {
      return 'ok';
    } else {
      throw new Error('object deep equal mismatch ' + left + ', ' + right);
    }
  } else if (null != (null != left ? left.array : void 0)) {
    console.log('leftb', left);
    return console.log(right);
  } else if (typeof left === 'object' && typeof right === 'object') {
    return function (accum$) {
      var key, lval;
      for (key in left) {
        lval = left[key];
        if (right[key] === void 0)
          throw new Error("'" + key + "' is not defined on right");
        accum$.push(checkAcceptableObject(lval, right[key]));
      }
      return accum$;
    }.call(this, []);
  } else if (left === void 0 || right === void 0) {
    return 'ignore now';
  } else {
    throw new Error('object deep equal mismatch ' + left + ', ' + right);
  }
};
initializeGlobalTypes = function (node) {
  node.addTypeObject('String', new TypeSymbol({
    type: 'String',
    'instanceof': function (expr) {
      return typeof expr.data === 'string';
    }
  }));
  node.addTypeObject('Number', new TypeSymbol({
    type: 'Number',
    'instanceof': function (expr) {
      return typeof expr.data === 'number';
    }
  }));
  node.addTypeObject('Boolean', new TypeSymbol({
    type: 'Boolean',
    'instanceof': function (expr) {
      return typeof expr.data === 'boolean';
    }
  }));
  node.addTypeObject('Object', new TypeSymbol({
    type: 'Object',
    'instanceof': function (expr) {
      return typeof expr.data === 'object';
    }
  }));
  node.addTypeObject('Array', new TypeSymbol({
    type: 'Array',
    'instanceof': function (expr) {
      return typeof expr.data === 'object';
    }
  }));
  return node.addTypeObject('Any', new TypeSymbol({
    type: 'Any',
    'instanceof': function (expr) {
      return true;
    }
  }));
};
VarSymbol = function () {
  function VarSymbol(param$) {
    var cache$1;
    {
      cache$1 = param$;
      this.type = cache$1.type;
      this.implicit = cache$1.implicit;
    }
  }
  return VarSymbol;
}();
TypeSymbol = function () {
  function TypeSymbol(param$) {
    var cache$1;
    {
      cache$1 = param$;
      this.type = cache$1.type;
      this['instanceof'] = cache$1['instanceof'];
    }
    if (null != this['instanceof'])
      this['instanceof'];
    else
      this['instanceof'] = function (t) {
        return t instanceof this.constructor;
      };
  }
  return TypeSymbol;
}();
Scope = function () {
  function Scope(param$) {
    if (null == param$)
      param$ = null;
    this.parent = param$;
    if (null != this.parent)
      this.parent.nodes.push(this);
    this.name = '';
    this.nodes = [];
    this._vars = {};
    this._types = {};
    this._this = null;
  }
  Scope.prototype.addType = function (symbol, type) {
    return this._types[symbol] = new TypeSymbol({ type: type });
  };
  Scope.prototype.addTypeObject = function (symbol, type_object) {
    return this._types[symbol] = type_object;
  };
  Scope.prototype.getType = function (symbol) {
    return null != (null != this._types[symbol] ? this._types[symbol].type : void 0) ? null != this._types[symbol] ? this._types[symbol].type : void 0 : void 0;
  };
  Scope.prototype.getTypeInScope = function (symbol) {
    return this.getType(symbol) || (null != this.parent ? this.parent.getTypeInScope(symbol) : void 0) || void 0;
  };
  Scope.prototype.addVar = function (symbol, type, implicit) {
    if (null == implicit)
      implicit = true;
    return this._vars[symbol] = new VarSymbol({
      type: type,
      implicit: implicit
    });
  };
  Scope.prototype.getVar = function (symbol) {
    return null != (null != this._vars[symbol] ? this._vars[symbol].type : void 0) ? null != this._vars[symbol] ? this._vars[symbol].type : void 0 : void 0;
  };
  Scope.prototype.getVarInScope = function (symbol) {
    return this.getVar(symbol) || (null != this.parent ? this.parent.getVarInScope(symbol) : void 0) || void 0;
  };
  Scope.prototype.isImplicitVar = function (symbol) {
    return !!(null != this._vars[symbol] ? this._vars[symbol].implicit : void 0);
  };
  Scope.prototype.isImplicitVarInScope = function (symbol) {
    return this.isImplicitVar(symbol) || (null != this.parent ? this.parent.isImplicitVarInScope(symbol) : void 0) || void 0;
  };
  Scope.prototype.extendTypeLiteral = function (node) {
    var key, ret, type, val;
    switch (typeof node) {
    case 'object':
      if (node instanceof Array) {
        return function (accum$) {
          var i;
          for (var i$ = 0, length$ = node.length; i$ < length$; ++i$) {
            i = node[i$];
            accum$.push(this.extendTypeLiteral(i));
          }
          return accum$;
        }.call(this, []);
      } else {
        ret = {};
        for (key in node) {
          val = node[key];
          ret[key] = this.extendTypeLiteral(val);
        }
        return ret;
      }
    case 'string':
      type = this.getTypeInScope(node);
      switch (typeof type) {
      case 'object':
        return this.extendTypeLiteral(type);
      case 'string':
        return type;
      }
    }
  };
  Scope.prototype.checkFunctionLiteral = function (left, right) {
    var i, l_arg, r_arg;
    left = this.extendTypeLiteral(left);
    right = this.extendTypeLiteral(right);
    for (var i$ = 0, length$ = left.args.length; i$ < length$; ++i$) {
      l_arg = left.args[i$];
      i = i$;
      r_arg = right.args[i];
      checkAcceptableObject(l_arg, r_arg);
    }
    if (right.returns !== 'Any')
      return checkAcceptableObject(left.returns, right.returns);
  };
  Scope.prototype.checkArrayLiteral = function (left, right) {
    var i, l_arg, r_arg;
    left = this.extendTypeLiteral(left);
    right = this.extendTypeLiteral(right);
    for (var i$ = 0, length$ = left.args.length; i$ < length$; ++i$) {
      l_arg = left.args[i$];
      i = i$;
      r_arg = right.args[i];
      checkAcceptableObject(l_arg, r_arg);
    }
    return checkAcceptableObject(left.returns, right.returns);
  };
  Scope.dump = function (node, prefix) {
    var key, val;
    if (null == prefix)
      prefix = '';
    console.log(prefix + ('[' + node.name + ']'));
    for (key in node._vars) {
      val = node._vars[key];
      console.log(prefix, ' +', key, '::', val);
    }
    return function (accum$) {
      var next;
      for (var i$ = 0, length$ = node.nodes.length; i$ < length$; ++i$) {
        next = node.nodes[i$];
        accum$.push(Scope.dump(next, prefix + '  '));
      }
      return accum$;
    }.call(this, []);
  };
  return Scope;
}();
walk = function (node, currentScope) {
  var alternate_annotation, args, assigning, cache$2, el, expected, expression, i, infered, key, last_annotation, left, n, nextScope, nop, obj, objectScope, possibilities, registered, right, symbol, target_type, type;
  console.log('---', null != node ? node.className : void 0, '---');
  switch (false) {
  case !!(null != node):
    return;
  case !(null != node.length):
    return function (accum$) {
      var s;
      for (var i$ = 0, length$ = node.length; i$ < length$; ++i$) {
        s = node[i$];
        accum$.push(walk(s, currentScope));
      }
      return accum$;
    }.call(this, []);
  case !(node.type === 'struct'):
    return currentScope.addType(node.name, node.expr);
  case !node['instanceof'](CS.Program):
    walk(node.body.statements, currentScope);
    return node.annotation = { type: 'Program' };
  case !node['instanceof'](CS.Block):
    walk(node.statements, currentScope);
    last_annotation = null != node.statements[node.statements.length - 1] ? node.statements[node.statements.length - 1].annotation : void 0;
    return node.annotation = last_annotation;
  case !node['instanceof'](CS.Conditional):
    walk(node.condition, currentScope);
    walk(node.consequent, currentScope);
    if (null != node.alternate)
      walk(node.alternate, currentScope);
    alternate_annotation = null != (null != node.alternate ? node.alternate.annotation : void 0) ? null != node.alternate ? node.alternate.annotation : void 0 : {
      type: 'Undefined',
      implicit: true
    };
    possibilities = [];
    for (var cache$1 = [
          node.consequent.annotation,
          alternate_annotation
        ], i$ = 0, length$ = cache$1.length; i$ < length$; ++i$) {
      n = cache$1[i$];
      if (!('undefined' !== typeof n && null != n))
        continue;
      if (null != n.possibilities) {
        for (var i$1 = 0, length$1 = n.possibilities.length; i$1 < length$1; ++i$1) {
          i = n.possibilities[i$1];
          possibilities.push(i);
        }
      } else {
        possibilities.push(n);
      }
    }
    return node.annotation = {
      possibilities: possibilities,
      implicit: true
    };
  case !(node['instanceof'](CS.ForIn) || node['instanceof'](CS.ForOf)):
    walk(node.target, currentScope);
    if (null != node.valAssignee)
      currentScope.addVar(node.valAssignee.data, null != (null != node.valAssignee && null != node.valAssignee.annotation ? node.valAssignee.annotation.type : void 0) ? null != node.valAssignee && null != node.valAssignee.annotation ? node.valAssignee.annotation.type : void 0 : 'Any');
    if (null != node.keyAssignee)
      currentScope.addVar(node.keyAssignee.data, null != (null != node.keyAssignee && null != node.keyAssignee.annotation ? node.keyAssignee.annotation.type : void 0) ? null != node.keyAssignee && null != node.keyAssignee.annotation ? node.keyAssignee.annotation.type : void 0 : 'Any');
    if (null != (null != node.target.annotation && null != node.target.annotation.type ? node.target.annotation.type.array : void 0)) {
      for (var i$2 = 0, length$2 = (null != node.target.annotation && null != node.target.annotation.type ? node.target.annotation.type.array : void 0).length; i$2 < length$2; ++i$2) {
        el = (null != node.target.annotation && null != node.target.annotation.type ? node.target.annotation.type.array : void 0)[i$2];
        if (null != node.valAssignee) {
          target_type = currentScope.extendTypeLiteral(el);
          checkAcceptableObject(node.valAssignee.annotation.type, target_type);
        }
      }
    } else if ((null != node.target && null != node.target.annotation ? node.target.annotation.type : void 0) instanceof Object) {
      if (node.target.annotation.type instanceof Object) {
        for (nop in node.target.annotation.type) {
          type = node.target.annotation.type[nop];
          checkAcceptableObject(currentScope.extendTypeLiteral(node.valAssignee.annotation.type), currentScope.extendTypeLiteral(type));
        }
      }
    }
    walk(node.body, currentScope);
    node.annotation = null != node.body ? node.body.annotation : void 0;
    delete currentScope._vars[null != node.valAssignee ? node.valAssignee.data : void 0];
    return delete currentScope._vars[null != node.keyAssignee ? node.keyAssignee.data : void 0];
  case !node['instanceof'](CS.ForOf):
    console.log('-----------------------------');
    console.log('forof', render(node.target));
    return console.log('-----------------------------');
  case !node['instanceof'](CS.String):
    if (null != node.annotation)
      return node.annotation;
    else
      return node.annotation = {
        type: 'String',
        implicit: true,
        primitive: true
      };
  case !node['instanceof'](CS.Bool):
    if (null != node.annotation)
      return node.annotation;
    else
      return node.annotation = {
        type: 'Boolean',
        implicit: true,
        primitive: true
      };
  case !node['instanceof'](CS.Numbers):
    if (null != node.annotation)
      return node.annotation;
    else
      return node.annotation = {
        type: 'Number',
        implicit: true,
        primitive: true
      };
  case !node['instanceof'](CS.Identifier):
    console.log('~~key', currentScope.getVarInScope(node.data));
    if (currentScope.getVarInScope(node.data)) {
      return node.annotation = { type: currentScope.getVarInScope(node.data) };
    } else {
      if (null != node.annotation)
        return node.annotation;
      else
        return node.annotation = {
          type: 'Any',
          implicit: true
        };
    }
  case !node['instanceof'](CS.MemberAccessOps):
    if (node['instanceof'](CS.MemberAccessOp)) {
      walk(node.expression, currentScope);
      type = currentScope.extendTypeLiteral(null != node.expression.annotation ? node.expression.annotation.type : void 0);
      if (null != type) {
        return node.annotation = {
          type: type[node.memberName],
          implicit: false
        };
      } else {
        return node.annotation = {
          type: 'Any',
          implicit: true
        };
      }
    }
  case !node['instanceof'](CS.ArrayInitialiser):
    walk(node.members, currentScope);
    if (null != node.annotation)
      return node.annotation;
    else
      return node.annotation = {
        type: {
          array: null != node.members ? node.members.map(function (m) {
            return null != m.annotation ? m.annotation.type : void 0;
          }) : void 0
        },
        implicit: true
      };
  case !node['instanceof'](CS.ObjectInitialiser):
    obj = {};
    nextScope = new Scope(currentScope);
    nextScope.name = 'object';
    for (var i$3 = 0, length$3 = node.members.length; i$3 < length$3; ++i$3) {
      {
        cache$2 = node.members[i$3];
        expression = cache$2.expression;
        key = cache$2.key;
      }
      if (!('undefined' !== typeof key && null != key))
        continue;
      walk(expression, nextScope);
      obj[key.data] = null != expression.annotation ? expression.annotation.type : void 0;
    }
    if (null != node.annotation)
      return node.annotation;
    else
      return node.annotation = {
        type: obj,
        implicit: true
      };
  case !node['instanceof'](CS.Class):
    return walk(node.body.statements, new Scope(currentScope));
  case !node['instanceof'](CS.Function):
    args = null != node.parameters ? node.parameters.map(function (param) {
      return null != (null != param.annotation ? param.annotation.type : void 0) ? null != param.annotation ? param.annotation.type : void 0 : 'Any';
    }) : void 0;
    node.annotation.type.args = args;
    objectScope = new Scope(currentScope);
    objectScope.name = '-lambda-';
    if (null != node.parameters)
      node.parameters.map(function (param) {
        try {
          if ('function' === typeof objectScope.addVar)
            return objectScope.addVar(param.data, null != (null != param.annotation ? param.annotation.type : void 0) ? null != param.annotation ? param.annotation.type : void 0 : 'Any');
        } catch (e$) {
          return 'ignore but brake on somewhere. why?';
        }
      });
    return walk(null != node.body ? node.body.statements : void 0, objectScope);
  case !node['instanceof'](CS.FunctionApplication):
    walk(node['arguments'], currentScope);
    expected = currentScope.getVarInScope(node['function'].data);
    if (null != expected && expected !== 'Any') {
      args = null != node['arguments'] ? node['arguments'].map(function (arg) {
        return null != arg.annotation ? arg.annotation.type : void 0;
      }) : void 0;
      currentScope.checkFunctionLiteral(expected, {
        args: args,
        returns: 'Any'
      });
      if (null != node.annotation)
        return node.annotation;
      else
        return node.annotation = {
          type: expected.returns,
          implicit: true
        };
    }
  case !node['instanceof'](CS.AssignOp):
    left = node.assignee;
    right = node.expression;
    walk(right, currentScope);
    walk(left, currentScope);
    if (!(null != left))
      return;
    if (left['instanceof'](CS.Identifier)) {
      symbol = left.data;
      registered = currentScope.getVarInScope(symbol);
      infered = null != right.annotation ? right.annotation.type : void 0;
      assigning = null != left.annotation ? currentScope.extendTypeLiteral(left.annotation.type) : void 0;
      if (null != assigning && null != registered && assigning !== 'Any') {
        throw new Error('double bind: ' + symbol);
      } else if (null != registered) {
        if (symbol === 'toString')
          return;
        if (!(registered === infered || registered === 'Any'))
          throw new Error("'" + symbol + "' is expected to " + registered + ' indeed ' + infered + ', by assignee');
      } else if (null != assigning) {
        if (assigning === 'Any') {
          return currentScope.addVar(symbol, 'Any', true);
        } else if (right['instanceof'](CS.Conditional)) {
          return function (accum$) {
            var p;
            for (var i$4 = 0, length$4 = right.annotation.possibilities.length; i$4 < length$4; ++i$4) {
              p = right.annotation.possibilities[i$4];
              accum$.push(checkAcceptableObject(assigning, p.type));
            }
            return accum$;
          }.call(this, []);
        } else if (right['instanceof'](CS.ForIn)) {
          return checkAcceptableObject(assigning.array, currentScope.extendTypeLiteral(right.annotation.type));
        } else if (null != (null != right.annotation && null != right.annotation.type ? right.annotation.type.array : void 0)) {
          for (var i$4 = 0, length$4 = right.annotation.type.array.length; i$4 < length$4; ++i$4) {
            el = right.annotation.type.array[i$4];
            target_type = currentScope.extendTypeLiteral(el);
            checkAcceptableObject(assigning.array, target_type);
          }
          return currentScope.addVar(symbol, 'Any', true);
        } else if (null != left.annotation.type.args && null != right.annotation.type.args) {
          if (right['instanceof'](CS.Function)) {
            currentScope.checkFunctionLiteral(left.annotation.type, right.annotation.type);
          } else {
            throw new Error('Right is not function');
          }
          return currentScope.addVar(symbol, left.annotation.type);
        } else if (typeof assigning === 'object') {
          if (null != right.annotation && null != left.annotation) {
            checkAcceptableObject(assigning, right.annotation.type);
            return currentScope.addVar(symbol, left.annotation.type, false);
          }
        } else if (assigning === infered) {
          return currentScope.addVar(symbol, left.annotation.type);
        } else {
          if (symbol === 'toString')
            return;
          throw new Error("'" + symbol + "' is expected to " + left.annotation.type + ' indeed ' + infered);
        }
      }
    } else if (left['instanceof'](CS.MemberAccessOp)) {
      if (left.expression.raw === '@')
        return;
      if (null != (null != left.annotation ? left.annotation.type : void 0) && null != (null != right.annotation ? right.annotation.type : void 0))
        if (left.annotation.type !== 'Any') {
          return checkAcceptableObject(currentScope.extendTypeLiteral(left.annotation.type), currentScope.extendTypeLiteral(right.annotation.type));
        }
    } else {
      return currentScope.addVar(symbol, 'Any');
    }
  }
};
module.exports = { checkNodes: checkNodes };
