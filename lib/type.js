// Generated by CoffeeScript 1.6.3
(function() {
  var CS, Scope, TypeSymbol, VarSymbol, checkNodes, guess_expr_type, initializeGlobalTypes, walk;

  CS = require('./nodes');

  guess_expr_type = function(expr) {
    var member, obj, _i, _len, _ref;
    if (expr == null) {
      return void 0;
    }
    if (expr.members != null) {
      obj = {};
      _ref = expr.members;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        member = _ref[_i];
        if (member.key != null) {
          obj[member.key.data] = guess_expr_type(member.expression);
        }
      }
      return obj;
    }
    if ((typeof expr.data) === 'number') {
      return 'Number';
    } else if ((typeof expr.data) === 'string') {
      return 'String';
    } else if ((typeof expr.data) === 'boolean') {
      return 'Boolean';
    } else if ((expr.parameters != null) && (expr.body != null)) {
      return 'Function';
    } else {
      return 'Any';
    }
  };

  VarSymbol = (function() {
    function VarSymbol(_arg) {
      this.type = _arg.type, this.implicit = _arg.implicit;
    }

    return VarSymbol;

  })();

  TypeSymbol = (function() {
    function TypeSymbol(_arg) {
      this.type = _arg.type, this["instanceof"] = _arg["instanceof"];
      if (this["instanceof"] == null) {
        this["instanceof"] = function(t) {
          return t instanceof this.constructor;
        };
      }
    }

    return TypeSymbol;

  })();

  Scope = (function() {
    function Scope(parent) {
      var _ref;
      this.parent = parent != null ? parent : null;
      if ((_ref = this.parent) != null) {
        _ref.nodes.push(this);
      }
      this.name = '';
      this.nodes = [];
      this._vars = {};
      this._types = {};
      this._this = null;
    }

    Scope.prototype.setType = function(symbol, type) {
      return this._types[symbol] = new TypeSymbol({
        type: type
      });
    };

    Scope.prototype.setTypeObject = function(symbol, type_object) {
      return this._types[symbol] = type_object;
    };

    Scope.prototype.getType = function(symbol) {
      var _ref, _ref1;
      return (_ref = (_ref1 = this._types[symbol]) != null ? _ref1.type : void 0) != null ? _ref : void 0;
    };

    Scope.prototype.getTypeInScope = function(symbol) {
      var _ref;
      return this.getType(symbol) || ((_ref = this.parent) != null ? _ref.getTypeInScope(symbol) : void 0) || void 0;
    };

    Scope.prototype.setVar = function(symbol, type, implicit) {
      if (implicit == null) {
        implicit = true;
      }
      return this._vars[symbol] = new VarSymbol({
        type: type,
        implicit: implicit
      });
    };

    Scope.prototype.getVar = function(symbol) {
      var _ref, _ref1;
      return (_ref = (_ref1 = this._vars[symbol]) != null ? _ref1.type : void 0) != null ? _ref : void 0;
    };

    Scope.prototype.getVarInScope = function(symbol) {
      var _ref;
      return this.getVar(symbol) || ((_ref = this.parent) != null ? _ref.getVarInScope(symbol) : void 0) || void 0;
    };

    Scope.dump = function(node, prefix) {
      var key, next, val, _i, _len, _ref, _ref1, _results;
      if (prefix == null) {
        prefix = '';
      }
      console.log(prefix + ("[" + node.name + "]"));
      _ref = node._vars;
      for (key in _ref) {
        val = _ref[key];
        console.log(prefix, ' +', key, '::', val);
      }
      _ref1 = node.nodes;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        next = _ref1[_i];
        _results.push(Scope.dump(next, prefix + '  '));
      }
      return _results;
    };

    Scope.prototype.extendTypeLiteral = function(object_or_name) {
      var key, obj, str, val;
      switch (typeof object_or_name) {
        case 'object':
          obj = object_or_name;
          for (key in obj) {
            val = obj[key];
            switch (typeof validate) {
              case 'object':
                obj[key] = this.extendTypeLiteral(val);
                break;
              case 'string':
                obj[key] = this.getTypeInScope(val);
            }
          }
          return obj;
        case 'string':
          str = object_or_name;
          return this.getTypeInScope(str);
      }
    };

    return Scope;

  })();

  initializeGlobalTypes = function(node) {
    node.setTypeObject('String', new TypeSymbol({
      type: 'String',
      "instanceof": function(expr) {
        return (typeof expr.data) === 'string';
      }
    }));
    node.setTypeObject('Number', new TypeSymbol({
      type: 'Number',
      "instanceof": function(expr) {
        return (typeof expr.data) === 'number';
      }
    }));
    node.setTypeObject('Boolean', new TypeSymbol({
      type: 'Boolean',
      "instanceof": function(expr) {
        return (typeof expr.data) === 'boolean';
      }
    }));
    node.setTypeObject('Object', new TypeSymbol({
      type: 'Object',
      "instanceof": function(expr) {
        return (typeof expr.data) === 'object';
      }
    }));
    return node.setTypeObject('Any', new TypeSymbol({
      type: 'Any',
      "instanceof": function(expr) {
        return true;
      }
    }));
  };

  checkNodes = function(cs_ast) {
    var i, root, _i, _len, _ref, _ref1;
    if (((_ref = cs_ast.body) != null ? _ref.statements : void 0) == null) {
      return;
    }
    console.log(cs_ast.body.statements);
    console.log('=====================');
    root = new Scope;
    root.name = 'root';
    _ref1 = ['global', 'exports', 'Module', 'module'];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      root.setVar(i, 'Any', true);
    }
    initializeGlobalTypes(root);
    walk(cs_ast.body.statements, root);
    return Scope.dump(root);
  };

  walk = function(node, currentScope) {
    var assigning, expected, infered, key, left, member, registered, right, scope, symbol, typeobj, val, _i, _len, _ref, _ref1;
    switch (false) {
      case node !== void 0:
        break;
      case node.length == null:
        return node.forEach(function(s) {
          return walk(s, currentScope);
        });
      case node.type !== 'struct':
        return currentScope.setType(node.name, node.expr);
      case !node["instanceof"](CS.String):
        return node.annotation != null ? node.annotation : node.annotation = {
          type: 'String',
          implicit: true
        };
      case !node["instanceof"](CS.Bool):
        return node.annotation != null ? node.annotation : node.annotation = {
          type: 'Boolean',
          implicit: true
        };
      case !node["instanceof"](CS.Numbers):
        return node.annotation != null ? node.annotation : node.annotation = {
          type: 'Number',
          implicit: true
        };
      case !node["instanceof"](CS.Class):
        return walk(node.body.statements, new Scope(currentScope));
      case !node["instanceof"](CS.Function):
        scope = new Scope(currentScope);
        scope.name = '-lambda-';
        node.parameters.map(function(param) {
          var _ref, _ref1;
          return scope.setVar(param.data, (_ref = (_ref1 = param.annotation) != null ? _ref1.type : void 0) != null ? _ref : 'Any');
        });
        return walk((_ref = node.body) != null ? _ref.statements : void 0, scope);
      case !node["instanceof"](CS.FunctionApplication):
        return walk(node["arguments"], currentScope);
      case !node["instanceof"](CS.AssignOp):
        left = node.assignee;
        right = node.expression;
        if (left.memberName != null) {
          symbol = left.expression.data;
          registered = currentScope.getVarInScope(symbol);
          if (registered == null) {
            return;
          }
          expected = registered[left.memberName];
          infered = guess_expr_type(right);
          if ((expected != null) && (expected === infered) || (registered === 'Any')) {
            '';
          } else {
            throw new Error("'" + symbol + "' is expected to " + registered + " (indeed " + infered + ") at member access");
          }
        }
        symbol = left.data;
        registered = currentScope.getVarInScope(symbol);
        infered = guess_expr_type(right);
        assigning = left.annotation != null ? currentScope.extendTypeLiteral(left.annotation.type) : void 0;
        if ((assigning != null) && (registered != null)) {
          throw new Error('double bind', symbol);
        } else if (right["instanceof"](CS.FunctionApplication)) {
          expected = currentScope.getVarInScope(right["function"].data);
          if (expected === void 0) {
            return currentScope.setVar(symbol, 'Any');
          } else if (assigning === (expected != null ? expected.returns : void 0)) {
            return currentScope.setVar(symbol, assigning);
          } else {
            throw new Error("'" + symbol + "' is expected to " + assigning + " indeed " + expected + ", by function call");
          }
        } else if (registered != null) {
          if (symbol === 'toString') {
            return;
          }
          if (!((registered === infered) || (registered === 'Any'))) {
            throw new Error("'" + symbol + "' is expected to " + registered + " indeed " + infered + ", by assignee");
          }
        } else if (assigning) {
          if (assigning === 'Any') {
            return currentScope.setVar(symbol, 'Any');
          } else if (left.annotation.type.type === 'Function') {
            return currentScope.setVar(symbol, left.annotation.type);
          } else if ((typeof assigning) === 'object') {
            typeobj = guess_expr_type(right);
            for (key in assigning) {
              val = assigning[key];
              if (typeobj[key] !== val) {
                throw new Error("'" + key + "' is expected to " + typeobj[key] + " indeed " + val);
              }
            }
            _ref1 = right.members;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              member = _ref1[_i];
              walk(member.expression, new Scope(currentScope));
            }
            return currentScope.setVar(symbol, left.annotation.type);
          } else if (assigning === infered) {
            currentScope.setVar(symbol, left.annotation.type);
            return walk(right, currentScope);
          } else {
            if (symbol === 'toString') {
              return;
            }
            throw new Error("'" + symbol + "' is expected to " + left.annotation.type + " indeed " + infered);
          }
        } else {
          currentScope.setVar(symbol, 'Any');
          return walk(right, currentScope);
        }
    }
  };

  module.exports = {
    checkNodes: checkNodes
  };

}).call(this);
