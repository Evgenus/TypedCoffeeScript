// Generated by CoffeeScript 2.0.0-beta8-dev
var _typecheck, checkNodes, console, CS, guess_expr_type, initializeGlobalTypes, Scope, TypeSymbol, VarSymbol;
CS = require('./nodes');
console = {
  log: function () {
  }
};
guess_expr_type = function (expr) {
  if (typeof expr.data === 'number') {
    return 'Number';
  } else if (typeof expr.data === 'string') {
    return 'String';
  } else if (typeof expr.data === 'boolean') {
    return 'Boolean';
  } else if (null != expr.parameters && null != expr.body) {
    return 'Function';
  } else {
    return 'Any';
  }
};
VarSymbol = function () {
  function VarSymbol(param$) {
    var cache$;
    {
      cache$ = param$;
      this.type = cache$.type;
      this.implicit = cache$.implicit;
    }
  }
  return VarSymbol;
}();
TypeSymbol = function () {
  function TypeSymbol(param$) {
    var cache$;
    {
      cache$ = param$;
      this.type = cache$.type;
      this['instanceof'] = cache$['instanceof'];
    }
    if (null != this['instanceof'])
      this['instanceof'];
    else
      this['instanceof'] = function (t) {
        return t instanceof this.constructor;
      };
  }
  return TypeSymbol;
}();
Scope = function () {
  function Scope() {
    this.name = '';
    this.nodes = [];
    this._vars = {};
    this._types = {};
    this._this = null;
    this.parent = null;
  }
  Scope.prototype.setType = function (symbol, type) {
    return this._types[symbol] = new TypeSymbol({ type: type });
  };
  Scope.prototype.sltTypeObject = function (symbol, type_object) {
    return this._types[symbol] = type_object;
  };
  Scope.prototype.getType = function (symbol) {
    return null != (null != this._types[symbol] ? this._types[symbol].type : void 0) ? null != this._types[symbol] ? this._types[symbol].type : void 0 : void 0;
  };
  Scope.prototype.getTypeInScope = function (symbol) {
    return this.getType(symbol) || (null != this.parent ? this.parent.getTypeInScope(symbol) : void 0) || void 0;
  };
  Scope.prototype.setVar = function (symbol, type, implicit) {
    if (null == implicit)
      implicit = true;
    return this._vars[symbol] = new VarSymbol({
      type: type,
      implicit: implicit
    });
  };
  Scope.prototype.getVar = function (symbol) {
    return null != (null != this._vars[symbol] ? this._vars[symbol].type : void 0) ? null != this._vars[symbol] ? this._vars[symbol].type : void 0 : void 0;
  };
  Scope.prototype.getVarInScope = function (symbol) {
    return this.getVar(symbol) || (null != this.parent ? this.parent.getVarInScope(symbol) : void 0) || void 0;
  };
  Scope.dump = function (node, prefix) {
    var key, val;
    if (null == prefix)
      prefix = '';
    console.log(prefix + ('[' + node.name + ']'));
    for (key in node._vars) {
      val = node._vars[key];
      console.log(prefix, ' +', key, '::', val);
    }
    return function (accum$) {
      var next;
      for (var i$ = 0, length$ = node.nodes.length; i$ < length$; ++i$) {
        next = node.nodes[i$];
        accum$.push(Scope.dump(next, prefix + '  '));
      }
      return accum$;
    }.call(this, []);
  };
  return Scope;
}();
initializeGlobalTypes = function (node) {
  return node.setTypeObject('Number', new TypeSymbol({
    type: 'Number',
    'instanceof': function (n) {
      return typeof n === 'number';
    }
  }));
};
checkNodes = function (cs_ast) {
  var i, root;
  if (!(null != (null != cs_ast.body ? cs_ast.body.statements : void 0)))
    return;
  console.log(cs_ast.body.statements);
  console.log('=====================');
  root = new Scope;
  root.name = 'root';
  for (var cache$ = [
        'global',
        'exports',
        'Module',
        'module'
      ], i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
    i = cache$[i$];
    root.setVar(i, 'Any', true);
  }
  _typecheck(cs_ast.body.statements, root);
  return Scope.dump(root);
};
_typecheck = function (node, currentScope) {
  var assigned_type, assignee, body, cache$, cache$1, cache$2, expected, expression, fnode, infered_type, member, name, registered_type, snode, symbol, type;
  if (node === void 0) {
    return;
  } else if (null != node.length) {
    node.forEach(function (s) {
      return _typecheck(s, currentScope);
    });
    return;
  } else if (node.type === 'struct') {
    console.log('struct', node);
    return currentScope.setType(node.name, node.expr);
  } else if (node instanceof CS.Function) {
    body = node.body;
    snode = new Scope;
    snode.name = '-lambda-';
    snode.parent = currentScope;
    currentScope.nodes.push(snode);
    return _typecheck(body.statements, snode);
  } else if (node instanceof CS.Class) {
    cache$ = node;
    body = cache$.body;
    name = cache$.name;
    snode = new Scope;
    snode.name = name.data;
    snode.parent = currentScope;
    currentScope.nodes.push(snode);
    return _typecheck(body.statements, snode);
  } else if (node instanceof CS.FunctionApplication) {
    return _typecheck(node['arguments'], currentScope);
  } else if (node instanceof CS.AssignOp && null != node.assignee.expression) {
    symbol = node.assignee.expression.data;
    member = node.assignee.memberName;
    registered_type = currentScope.getVarInScope(symbol);
    if (!(null != registered_type))
      return;
    type = registered_type[member];
    infered_type = guess_expr_type(node.expression);
    if (null != type && type === infered_type || registered_type === 'Any') {
      return '';
    } else {
      throw new Error("'" + symbol + "' is expected to " + registered_type + ' (indeed ' + infered_type + ') at member access');
    }
  } else if (node instanceof CS.AssignOp) {
    cache$1 = node;
    assignee = cache$1.assignee;
    expression = cache$1.expression;
    symbol = assignee.data;
    registered_type = currentScope.getVarInScope(symbol);
    infered_type = guess_expr_type(expression);
    assigned_type = typeof (null != assignee.annotation ? assignee.annotation.type : void 0) === 'object' ? null != assignee.annotation ? assignee.annotation.type : void 0 : (cache$2 = currentScope.getTypeInScope(null != assignee.annotation ? assignee.annotation.type : void 0), null != cache$2 ? cache$2 : null != assignee.annotation ? assignee.annotation.type : void 0);
    console.log(assigned_type, currentScope.getTypeInScope(null != assignee.annotation ? assignee.annotation.type : void 0));
    if (null != registered_type && null != assigned_type) {
      throw new Error('double bind', symbol);
    } else if (null != node.expression['function']) {
      expected = currentScope.getVarInScope(expression['function'].data);
      if (expected === void 0) {
        return currentScope.setVar(symbol, 'Any');
      } else if (assigned_type === (null != expected ? expected.returns : void 0)) {
        return currentScope.setVar(symbol, assigned_type);
      } else {
        throw new Error("'" + symbol + "' is expected to " + assigned_type + ' indeed ' + expected + ', by function call');
      }
    } else if (null != registered_type) {
      if (symbol === 'toString') {
        return '';
      } else if (!(registered_type === infered_type || registered_type === 'Any')) {
        throw new Error("'" + symbol + "' is expected to " + registered_type + ' indeed ' + infered_type + ', by assignee');
      }
    } else if (assigned_type) {
      if (assigned_type === 'Any') {
        return currentScope.setVar(symbol, 'Any');
      } else if (assignee.annotation.type.type === 'Function') {
        return currentScope.setVar(symbol, assignee.annotation.type);
      } else if (typeof assigned_type === 'object') {
        return currentScope.setVar(symbol, assignee.annotation.type);
      } else if (assigned_type === infered_type) {
        currentScope.setVar(symbol, assignee.annotation.type);
        if (infered_type === 'Function') {
          fnode = new Scope;
          fnode.name = symbol;
          fnode.parent = currentScope;
          node.expression.parameters.map(function (param) {
            return fnode.setVar(param.data, null != (null != param.annotation ? param.annotation.type : void 0) ? null != param.annotation ? param.annotation.type : void 0 : 'Any');
          });
          currentScope.nodes.push(fnode);
          return _typecheck(node.expression.body.statements, fnode);
        }
      } else {
        if (symbol === 'toString')
          return;
        throw new Error("'" + symbol + "' is expected to " + assignee.annotation.type + ' indeed ' + infered_type);
      }
    } else {
      currentScope.setVar(symbol, 'Any');
      if (infered_type === 'Function' && null != (null != node.expression.body ? node.expression.body.statements : void 0)) {
        fnode = new Scope;
        fnode.name = symbol;
        fnode.parent = currentScope;
        currentScope.nodes.push(fnode);
        return _typecheck(node.expression.body.statements, fnode);
      }
    }
  }
};
module.exports = { checkNodes: checkNodes };
