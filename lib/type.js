// Generated by CoffeeScript 1.6.3
(function() {
  var ScopeNode, VarSymbol, checkNodes, console, guess_expr_type, _typecheck;

  console = {
    log: function() {}
  };

  guess_expr_type = function(expr) {
    if ((typeof expr.data) === 'number') {
      return 'Number';
    } else if ((typeof expr.data) === 'string') {
      return 'String';
    } else if ((typeof expr.data) === 'boolean') {
      return 'Boolean';
    } else if ((expr.parameters != null) && (expr.body != null)) {
      return 'Function';
    } else {
      return 'Any';
    }
  };

  VarSymbol = (function() {
    function VarSymbol(_arg) {
      this.type = _arg.type, this.implicit = _arg.implicit;
    }

    return VarSymbol;

  })();

  ScopeNode = (function() {
    function ScopeNode() {
      this.name = '';
      this.nodes = [];
      this._vars = {};
      this._types = {};
      this._this = null;
      this.parent = null;
    }

    ScopeNode.prototype.setVar = function(symbol, type, implicit) {
      if (implicit == null) {
        implicit = true;
      }
      return this._vars[symbol] = new VarSymbol({
        type: type,
        implicit: implicit
      });
    };

    ScopeNode.prototype.getVar = function(symbol) {
      var _ref, _ref1;
      return (_ref = (_ref1 = this._vars[symbol]) != null ? _ref1.type : void 0) != null ? _ref : void 0;
    };

    ScopeNode.prototype.getScopedVar = function(symbol) {
      var _ref;
      return this.getVar(symbol) || ((_ref = this.parent) != null ? _ref.getScopedVar(symbol) : void 0) || void 0;
    };

    ScopeNode.dump = function(node, prefix) {
      var key, next, val, _i, _len, _ref, _ref1, _results;
      if (prefix == null) {
        prefix = '';
      }
      console.log(prefix + ("[" + node.name + "]"));
      _ref = node._vars;
      for (key in _ref) {
        val = _ref[key];
        console.log(prefix, ' +', key, '::', val);
      }
      _ref1 = node.nodes;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        next = _ref1[_i];
        _results.push(ScopeNode.dump(next, prefix + '  '));
      }
      return _results;
    };

    return ScopeNode;

  })();

  checkNodes = function(cs_ast) {
    var i, root, _i, _len, _ref, _ref1;
    if (((_ref = cs_ast.body) != null ? _ref.statements : void 0) == null) {
      return;
    }
    console.log(cs_ast.body.statements);
    console.log('=====================');
    root = new ScopeNode;
    root.name = 'root';
    _ref1 = ['global', 'exports', 'Module', 'module'];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      root.setVar(i, 'Any', true);
    }
    _typecheck(cs_ast.body.statements, root);
    return ScopeNode.dump(root);
  };

  _typecheck = function(node, parentScope) {
    var assigned_type, assignee, body, expected, expression, fnode, infered_type, member, name, registered_type, snode, symbol, type, _ref, _ref1, _ref2;
    if (node === void 0) {

    } else if (node.length != null) {
      node.forEach(function(s) {
        return _typecheck(s, parentScope);
      });
    } else if (node.type === 'struct') {
      return parentScope.setVar(node.type.name, node.type.expr);
    } else if (guess_expr_type(node) === 'Function') {
      body = node.body;
      snode = new ScopeNode;
      snode.name = '-lambda-';
      snode.parent = parentScope;
      parentScope.nodes.push(snode);
      return _typecheck(body.statements, snode);
    } else if ((node.nameAssignee != null) && (node.body != null)) {
      body = node.body, name = node.name;
      snode = new ScopeNode;
      snode.name = name.data;
      snode.parent = parentScope;
      parentScope.nodes.push(snode);
      return _typecheck(body.statements, snode);
    } else if ((node["function"] != null) && (node["arguments"] != null)) {
      return _typecheck(node["arguments"], parentScope);
    } else if ((((_ref = node.assignee) != null ? _ref.memberName : void 0) != null) && (node.expression != null)) {
      symbol = node.assignee.expression.data;
      member = node.assignee.memberName;
      registered_type = parentScope.getScopedVar(symbol);
      if (registered_type == null) {
        return;
      }
      type = registered_type[member];
      infered_type = guess_expr_type(node.expression);
      if ((type != null) && (type === infered_type) || (registered_type === 'Any')) {
        return '';
      } else {
        throw new Error("'" + symbol + "' is expected to " + registered_type + " (indeed " + infered_type + ") at member access");
      }
    } else if ((node.assignee != null) && (node.expression != null)) {
      assignee = node.assignee, expression = node.expression;
      symbol = assignee.data;
      registered_type = parentScope.getScopedVar(symbol);
      infered_type = guess_expr_type(expression);
      assigned_type = (_ref1 = assignee.annotation) != null ? _ref1.type : void 0;
      if ((registered_type != null) && (assigned_type != null)) {
        throw new Error('double bind', symbol);
      } else if (node.expression["function"] != null) {
        expected = parentScope.getScopedVar(expression["function"].data);
        if (expected === void 0) {
          return parentScope.setVar(symbol, 'Any');
        } else if (assigned_type === (expected != null ? expected.returns : void 0)) {
          return parentScope.setVar(symbol, assigned_type);
        } else {
          throw new Error("'" + symbol + "' is expected to " + assigned_type + " indeed " + expected + ", by function call");
        }
      } else if (registered_type != null) {
        if (symbol === 'toString') {
          return '';
        } else if (!((registered_type === infered_type) || (registered_type === 'Any'))) {
          throw new Error("'" + symbol + "' is expected to " + registered_type + " indeed " + infered_type + ", by assignee");
        }
      } else if (assigned_type) {
        if (assigned_type === 'Any') {
          return parentScope.setVar(symbol, 'Any');
        } else if (assignee.annotation.type.type === 'Function') {
          return parentScope.setVar(symbol, assignee.annotation.type);
        } else if ((typeof assigned_type) === 'object') {
          return parentScope.setVar(symbol, assignee.annotation.type);
        } else if (assigned_type === infered_type) {
          parentScope.setVar(symbol, assignee.annotation.type);
          if (infered_type === 'Function') {
            fnode = new ScopeNode;
            fnode.name = symbol;
            fnode.parent = parentScope;
            node.expression.parameters.map(function(param) {
              var _ref2, _ref3;
              return fnode.setVar(param.data, (_ref2 = (_ref3 = param.annotation) != null ? _ref3.type : void 0) != null ? _ref2 : 'Any');
            });
            parentScope.nodes.push(fnode);
            return _typecheck(node.expression.body.statements, fnode);
          }
        } else {
          if (symbol === 'toString') {
            return;
          }
          throw new Error("'" + symbol + "' is expected to " + assignee.annotation.type + " indeed " + infered_type);
        }
      } else {
        parentScope.setVar(symbol, 'Any');
        if (infered_type === 'Function' && (((_ref2 = node.expression.body) != null ? _ref2.statements : void 0) != null)) {
          fnode = new ScopeNode;
          fnode.name = symbol;
          fnode.parent = parentScope;
          parentScope.nodes.push(fnode);
          return _typecheck(node.expression.body.statements, fnode);
        }
      }
    }
  };

  module.exports = {
    checkNodes: checkNodes
  };

}).call(this);
