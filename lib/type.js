// Generated by CoffeeScript 1.6.3
(function() {
  var CS, Scope, TypeSymbol, VarSymbol, checkAcceptableObject, checkNodes, console, initializeGlobalTypes, render, walk;

  console = {
    log: function() {}
  };

  CS = require('./nodes');

  render = require('prettyjson').render;

  checkNodes = function(cs_ast) {
    var i, root, _i, _len, _ref, _ref1;
    if (((_ref = cs_ast.body) != null ? _ref.statements : void 0) == null) {
      return;
    }
    console.log('AST ==================');
    console.log(render(cs_ast));
    console.log('================== AST');
    root = new Scope;
    root.name = 'root';
    _ref1 = ['global', 'exports', 'module'];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      root.addVar(i, 'Any', true);
    }
    initializeGlobalTypes(root);
    walk(cs_ast.body.statements, root);
    return console.log('================== Scope');
  };

  VarSymbol = (function() {
    function VarSymbol(_arg) {
      this.type = _arg.type, this.implicit = _arg.implicit;
    }

    return VarSymbol;

  })();

  TypeSymbol = (function() {
    function TypeSymbol(_arg) {
      this.type = _arg.type, this["instanceof"] = _arg["instanceof"];
      if (this["instanceof"] == null) {
        this["instanceof"] = function(t) {
          return t instanceof this.constructor;
        };
      }
    }

    return TypeSymbol;

  })();

  Scope = (function() {
    function Scope(parent) {
      var _ref;
      this.parent = parent != null ? parent : null;
      if ((_ref = this.parent) != null) {
        _ref.nodes.push(this);
      }
      this.name = '';
      this.nodes = [];
      this._vars = {};
      this._types = {};
      this._this = null;
    }

    Scope.prototype.addType = function(symbol, type) {
      return this._types[symbol] = new TypeSymbol({
        type: type
      });
    };

    Scope.prototype.addTypeObject = function(symbol, type_object) {
      return this._types[symbol] = type_object;
    };

    Scope.prototype.getType = function(symbol) {
      var _ref, _ref1;
      return (_ref = (_ref1 = this._types[symbol]) != null ? _ref1.type : void 0) != null ? _ref : void 0;
    };

    Scope.prototype.getTypeInScope = function(symbol) {
      var _ref;
      return this.getType(symbol) || ((_ref = this.parent) != null ? _ref.getTypeInScope(symbol) : void 0) || void 0;
    };

    Scope.prototype.addVar = function(symbol, type, implicit) {
      if (implicit == null) {
        implicit = true;
      }
      return this._vars[symbol] = new VarSymbol({
        type: type,
        implicit: implicit
      });
    };

    Scope.prototype.getVar = function(symbol) {
      var _ref, _ref1;
      return (_ref = (_ref1 = this._vars[symbol]) != null ? _ref1.type : void 0) != null ? _ref : void 0;
    };

    Scope.prototype.getVarInScope = function(symbol) {
      var _ref;
      return this.getVar(symbol) || ((_ref = this.parent) != null ? _ref.getVarInScope(symbol) : void 0) || void 0;
    };

    Scope.dump = function(node, prefix) {
      var key, next, val, _i, _len, _ref, _ref1, _results;
      if (prefix == null) {
        prefix = '';
      }
      console.log(prefix + ("[" + node.name + "]"));
      _ref = node._vars;
      for (key in _ref) {
        val = _ref[key];
        console.log(prefix, ' +', key, '::', val);
      }
      _ref1 = node.nodes;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        next = _ref1[_i];
        _results.push(Scope.dump(next, prefix + '  '));
      }
      return _results;
    };

    Scope.prototype.extendTypeLiteral = function(node) {
      var i, key, ret, type, val;
      switch (typeof node) {
        case 'object':
          if (node instanceof Array) {
            return (function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = node.length; _i < _len; _i++) {
                i = node[_i];
                _results.push(this.extendTypeLiteral(i));
              }
              return _results;
            }).call(this);
          } else {
            ret = {};
            for (key in node) {
              val = node[key];
              ret[key] = this.extendTypeLiteral(val);
            }
            return ret;
          }
          break;
        case 'string':
          type = this.getTypeInScope(node);
          switch (typeof type) {
            case 'object':
              return this.extendTypeLiteral(type);
            case 'string':
              return type;
          }
      }
    };

    Scope.prototype.checkFunctionLiteral = function(left, right) {
      var i, l_arg, r_arg, _i, _len, _ref;
      left = this.extendTypeLiteral(left);
      right = this.extendTypeLiteral(right);
      console.log('left', left);
      console.log('right', right);
      _ref = left.args;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        l_arg = _ref[i];
        r_arg = right.args[i];
        checkAcceptableObject(l_arg, r_arg);
      }
      return checkAcceptableObject(left.returns, right.returns);
    };

    return Scope;

  })();

  checkAcceptableObject = function(left, right) {
    var lkey, lval, _results;
    if (((typeof left) === 'string') && ((typeof right) === 'string')) {
      if ((left === right) || (left === 'Any') || (right === 'Any')) {
        return 'ok';
      } else {
        throw new Error("object deep equal mismatch " + left + ", " + right);
      }
    } else if (((typeof left) === 'object') && ((typeof right) === 'object')) {
      _results = [];
      for (lkey in left) {
        lval = left[lkey];
        _results.push(checkAcceptableObject(lval, right[lkey]));
      }
      return _results;
    } else if ((left === void 0) || (right === void 0)) {
      return "ignore now";
    } else {
      throw new Error("object deep equal mismatch " + left + ", " + right);
    }
  };

  initializeGlobalTypes = function(node) {
    node.addTypeObject('String', new TypeSymbol({
      type: 'String',
      "instanceof": function(expr) {
        return (typeof expr.data) === 'string';
      }
    }));
    node.addTypeObject('Number', new TypeSymbol({
      type: 'Number',
      "instanceof": function(expr) {
        return (typeof expr.data) === 'number';
      }
    }));
    node.addTypeObject('Boolean', new TypeSymbol({
      type: 'Boolean',
      "instanceof": function(expr) {
        return (typeof expr.data) === 'boolean';
      }
    }));
    node.addTypeObject('Object', new TypeSymbol({
      type: 'Object',
      "instanceof": function(expr) {
        return (typeof expr.data) === 'object';
      }
    }));
    return node.addTypeObject('Any', new TypeSymbol({
      type: 'Any',
      "instanceof": function(expr) {
        return true;
      }
    }));
  };

  walk = function(node, currentScope) {
    var args, assigning, expected, expression, infered, key, left, nextScope, obj, objectScope, registered, right, symbol, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    switch (false) {
      case node !== void 0:
        break;
      case node.length == null:
        return node.forEach(function(s) {
          return walk(s, currentScope);
        });
      case node.type !== 'struct':
        return currentScope.addType(node.name, node.expr);
      case !node["instanceof"](CS.Program):
        walk(node.body.statements, currentScope);
        return node.annotation = {
          type: 'Program'
        };
      case !node["instanceof"](CS.Identifier):
        return node.annotation != null ? node.annotation : node.annotation = {
          type: currentScope.getVar(node.data) != null ? currentScope.getVar(node.data) : 'Any'
        };
      case !node["instanceof"](CS.String):
        return node.annotation != null ? node.annotation : node.annotation = {
          type: 'String',
          implicit: true
        };
      case !node["instanceof"](CS.Bool):
        return node.annotation != null ? node.annotation : node.annotation = {
          type: 'Boolean',
          implicit: true
        };
      case !node["instanceof"](CS.ObjectInitialiser):
        obj = {};
        nextScope = new Scope(currentScope);
        nextScope.name = 'object';
        _ref = node.members;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          _ref1 = _ref[_i], expression = _ref1.expression, key = _ref1.key;
          if (!(key != null)) {
            continue;
          }
          walk(expression, nextScope);
          obj[key.data] = (_ref2 = expression.annotation) != null ? _ref2.type : void 0;
        }
        return node.annotation != null ? node.annotation : node.annotation = {
          type: obj,
          implicit: true
        };
      case !node["instanceof"](CS.Numbers):
        return node.annotation != null ? node.annotation : node.annotation = {
          type: 'Number',
          implicit: true
        };
      case !node["instanceof"](CS.Class):
        return walk(node.body.statements, new Scope(currentScope));
      case !node["instanceof"](CS.Function):
        args = node.parameters.map(function(param) {
          var _ref3, _ref4;
          return (_ref3 = (_ref4 = param.annotation) != null ? _ref4.type : void 0) != null ? _ref3 : 'Any';
        });
        node.annotation.type.args = args;
        objectScope = new Scope(currentScope);
        objectScope.name = '-lambda-';
        node.parameters.map(function(param) {
          var _ref3, _ref4;
          try {
            return typeof objectScope.addVar === "function" ? objectScope.addVar(param.data, (_ref3 = (_ref4 = param.annotation) != null ? _ref4.type : void 0) != null ? _ref3 : 'Any') : void 0;
          } catch (_error) {
            return 'ignore but brake on somewhere. why?';
          }
        });
        return walk((_ref3 = node.body) != null ? _ref3.statements : void 0, objectScope);
      case !node["instanceof"](CS.FunctionApplication):
        return walk(node["arguments"], currentScope);
      case !node["instanceof"](CS.AssignOp):
        left = node.assignee;
        right = node.expression;
        walk(right, currentScope);
        if (left.memberName != null) {
          symbol = left.expression.data;
          registered = currentScope.getVarInScope(symbol);
          if (registered == null) {
            return;
          }
          expected = registered[left.memberName];
          infered = (_ref4 = right.annotation) != null ? _ref4.type : void 0;
          if ((expected != null) && (expected === infered) || (registered === 'Any')) {
            '';
          } else {
            throw new Error("'" + symbol + "' is expected to " + registered + " (indeed " + infered + ") at member access");
          }
        }
        symbol = left.data;
        registered = currentScope.getVarInScope(symbol);
        infered = (_ref5 = right.annotation) != null ? _ref5.type : void 0;
        assigning = left.annotation != null ? currentScope.extendTypeLiteral(left.annotation.type) : void 0;
        if ((assigning != null) && (registered != null)) {
          throw new Error('double bind', symbol);
        } else if (right["instanceof"](CS.FunctionApplication)) {
          expected = currentScope.getVarInScope(right["function"].data);
          if (expected === void 0) {
            return currentScope.addVar(symbol, 'Any');
          } else if (assigning === (expected != null ? expected.returns : void 0)) {
            return currentScope.addVar(symbol, assigning);
          } else {
            throw new Error("'" + symbol + "' is expected to " + assigning + " indeed " + expected + ", by function call");
          }
        } else if (registered != null) {
          if (symbol === 'toString') {
            return;
          }
          if (!((registered === infered) || (registered === 'Any'))) {
            throw new Error("'" + symbol + "' is expected to " + registered + " indeed " + infered + ", by assignee");
          }
        } else if (assigning != null) {
          if (assigning === 'Any') {
            return currentScope.addVar(symbol, 'Any');
          } else if ((left.annotation.type.args != null) && (right.annotation.type.args != null)) {
            if (right["instanceof"](CS.Function)) {
              currentScope.checkFunctionLiteral(left.annotation.type, right.annotation.type);
            } else {
              throw new Error("assigining right is function");
            }
            return currentScope.addVar(symbol, left.annotation.type);
          } else if ((typeof assigning) === 'object') {
            checkAcceptableObject(assigning, right.annotation.type);
            return currentScope.addVar(symbol, left.annotation.type, false);
          } else if (assigning === infered) {
            return currentScope.addVar(symbol, left.annotation.type);
          } else {
            if (symbol === 'toString') {
              return;
            }
            throw new Error("'" + symbol + "' is expected to " + left.annotation.type + " indeed " + infered);
          }
        } else {
          return currentScope.addVar(symbol, 'Any');
        }
    }
  };

  module.exports = {
    checkNodes: checkNodes
  };

}).call(this);
